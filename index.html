<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>–ì—Ä–∞–≤–∏—Ç–∞—Ü–∏–æ–Ω–Ω–∞—è –∏–≥—Ä–∞</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        html, body {
            margin: 0;
            padding: 0;
            height: 100%;
            overflow: hidden;
            font-family: Arial, sans-serif;
            background: #000;
            touch-action: none;
        }
        .menu-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            max-height: 100vh;
            background: #111;
            color: white;
            display: flex;
            flex-direction: column;
            justify-content: flex-start;
            align-items: center;
            z-index: 100;
            padding: 8vh 5vw 5vh;
            box-sizing: border-box;
            overflow-y: auto;
            text-align: center;
            touch-action: pan-y;
        }
        .menu-screen.disabled {
            pointer-events: none;
            opacity: 0.7;
        }
        fieldset.setup-group {
            margin: 10px 0;
            width: 100%;
            max-width: 300px;
            margin-left: auto;
            margin-right: auto;
            border: none;
            padding: 0;
        }
        legend {
            display: block;
            margin-bottom: 5px;
            font-size: 14px;
            text-align: left;
            width: 100%;
            padding: 0;
            color: white;
        }
        input, select {
            width: 100%;
            padding: 10px;
            background: #333;
            border: 1px solid #555;
            color: white;
            border-radius: 5px;
            font-size: 16px;
            text-align: center;
        }
        select:disabled {
            background: #222;
            color: #888;
        }
        .planet-settings {
            display: flex;
            justify-content: space-between;
            gap: 8px;
            margin-top: 8px;
            flex-wrap: wrap;
        }
        .planet-setting {
            display: flex;
            flex-direction: column;
            align-items: center;
            min-width: 70px;
            flex: 1;
        }
        .planet-color-preview {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            margin-bottom: 4px;
            border: 1px solid #666;
        }
        .planet-setting input,
        .planet-setting select {
            width: 100%;
            padding: 4px;
            font-size: 12px;
            text-align: center;
        }
        button {
            background: #4CAF50;
            color: white;
            border: none;
            padding: 15px 30px;
            font-size: 18px;
            border-radius: 5px;
            cursor: pointer;
            margin: 20px 0;
        }
        button:hover {
            background: #45a049;
        }
        #gameCanvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #000;
            z-index: 10;
            touch-action: none;
        }
        .error {
            color: #ff4444;
            font-size: 12px;
            margin-top: 5px;
            text-align: center;
            max-width: 300px;
        }
        h1 {
            margin-bottom: 20px;
            text-align: center;
            font-size: clamp(20px, 5vw, 28px);
        }
        .warning {
            color: #ffaa00;
            font-size: 14px;
            margin: 10px 0;
            text-align: center;
            max-width: 300px;
            background: rgba(255, 170, 0, 0.1);
            padding: 10px;
            border-radius: 5px;
        }
        #SettingsScreen,
        #IndividualPlanetSettingsScreen {
            display: none;
        }
        @media (min-width: 700px) and (orientation: landscape) {
            .planet-settings-advanced {
                display: flex;
                flex-wrap: wrap;
                gap: 20px;
                margin-top: 15px;
            }
            .planet-settings-advanced fieldset.setup-group {
                flex: 1;
                min-width: calc(50% - 10px);
                margin-top: 0;
            }
        }
        .setup-columns {
            display: flex;
            flex-direction: column;
            align-items: center;
            width: 100%;
            max-width: 640px;
            gap: 20px;
        }
        @media (min-width: 768px) and (orientation: landscape) {
            .menu-screen {
                padding: 20px;
                align-items: center;
                text-align: left;
                justify-content: flex-start;
            }
            .setup-columns {
                flex-direction: row;
                align-items: stretch;
                min-height: 450px;
            }
            .setup-column {
                flex: 1;
                display: flex;
                flex-direction: column;
            }
            .setup-column > fieldset.setup-group {
                max-width: none;
                margin-left: 0;
                margin-right: 0;
            }
            #planetSettingsContainer {
                display: flex;
                flex-wrap: wrap;
                gap: 15px;
            }
            #planetSettingsContainer .planet-setting {
                flex: 1 1 calc(33.333% - 10px);
            }
            .top-buttons-row {
                align-self: flex-start;
            }
        }
        .manual-mode-indicator {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 255, 0, 0.9);
            color: #000;
            padding: 10px 20px;
            border-radius: 5px;
            font-size: 16px;
            font-weight: bold;
            z-index: 50;
            pointer-events: none;
            transition: opacity 0.3s;
            display: none;
        }
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.95);
            z-index: 200;
            display: none;
            justify-content: center;
            align-items: center;
            padding: 20px;
            box-sizing: border-box;
        }
        .about-modal-content,
        .license-modal-content,
        .offline-modal-content {
            background: #1a1a1a;
            color: #eee;
            border-radius: 10px;
            max-width: 90vw;
            max-height: 85vh;
            overflow-y: auto;
            -webkit-overflow-scrolling: touch;
        }
        .about-modal-content {
            padding: 30px;
            max-width: 500px;
        }
        .about-modal-content h2 {
            margin-top: 0;
            margin-bottom: 20px;
            text-align: center;
            color: #fff;
        }
        .about-modal-content p {
            margin: 10px 0;
            line-height: 1.5;
        }
        .about-description-block {
            margin: 20px 0;
            padding: 15px;
            background: #111;
            border-radius: 5px;
        }
        .about-buttons {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            justify-content: center;
            margin: 20px 0;
        }
        .about-footer {
            text-align: center;
            margin-top: 20px;
        }
        .license-modal-content {
            padding: 25px;
            max-width: 800px;
        }
        .license-modal-content h3 {
            margin-top: 0;
            margin-bottom: 15px;
            color: #fff;
        }
        .license-modal-content pre {
            white-space: pre-wrap;
            word-wrap: break-word;
            font-family: monospace;
            font-size: 11px;
            line-height: 1.5;
            margin: 0;
        }
        .offline-modal-content {
            padding: 25px;
            max-width: 500px;
        }
        .offline-modal-content h3 {
            color: #ffaa00;
            margin-top: 0;
        }
        .offline-instructions {
            background: #111;
            padding: 15px;
            border-radius: 5px;
            margin: 20px 0;
        }
        .offline-instructions ol {
            text-align: left;
            line-height: 1.8;
            padding-left: 20px;
        }
        .offline-link {
            margin: 20px 0;
            text-align: center;
        }
        .offline-link a {
            color: #66aaff;
            text-decoration: none;
        }
        .offline-link a:hover {
            text-decoration: underline;
        }
        .primary-btn {
            background: #0066cc;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 16px;
        }
        .secondary-btn {
            background: #444;
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
            margin: 5px;
        }
        .primary-btn:hover {
            background: #0052a3;
        }
        .secondary-btn:hover {
            background: #555;
        }
        .modal-footer {
            text-align: center;
            margin-top: 20px;
        }
        .license-modal-content::-webkit-scrollbar,
        .offline-modal-content::-webkit-scrollbar,
        .about-modal-content::-webkit-scrollbar {
            width: 8px;
        }
        .license-modal-content::-webkit-scrollbar-track,
        .offline-modal-content::-webkit-scrollbar-track,
        .about-modal-content::-webkit-scrollbar-track {
            background: #2a2a2a;
            border-radius: 4px;
        }
        .license-modal-content::-webkit-scrollbar-thumb,
        .offline-modal-content::-webkit-scrollbar-thumb,
        .about-modal-content::-webkit-scrollbar-thumb {
            background: #555;
            border-radius: 4px;
        }
        .license-modal-content::-webkit-scrollbar-thumb:hover,
        .offline-modal-content::-webkit-scrollbar-thumb:hover,
        .about-modal-content::-webkit-scrollbar-thumb:hover {
            background: #777;
        }
        .top-buttons-row {
            display: flex;
            gap: 15px;
            width: 100%;
            margin: 0 auto 5px !important;
        }
        .top-buttons-row button {
            flex: 1;
            margin: 0 !important;
        }
        @media (max-width: 767px) {
            .top-buttons-row {
                flex-direction: column;
                margin: 0 auto 5px !important;
            }
        }
        #menuControls {
            margin-top: 5px;
            margin-bottom: 20px;
            width: 100%;
            display: flex;
            flex-direction: row;
            gap: 10px;
            justify-content: center;
            align-items: stretch;
        }
        #menuControls > select,
        #menuControls > button {
            flex: 1;
            margin: 0 !important;
            min-width: 0;
            background: #008080 !important;
            color: white;
            border: 1px solid #006666 !important;
            border-radius: 5px;
            font-size: 16px;
            text-align: center;
            padding: 10px;
            cursor: pointer;
            box-sizing: border-box;
        }
        #menuControls > select {
            appearance: none;
            background-image: url("data:image/svg+xml;charset=UTF-8,%3csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='white' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3e%3cpolyline points='6 9 12 15 18 9'%3e%3c/polyline%3e%3c/svg%3e");
            background-repeat: no-repeat;
            background-position: right 10px center;
            background-size: 12px;
            padding-right: 30px;
        }
        #menuControls > button:hover,
        #menuControls > select:hover {
            background: #009999 !important;
        }
        @media (max-width: 480px) {
            #menuControls {
                gap: 8px;
            }
            #menuControls > * {
                font-size: 14px;
                padding: 8px 16px !important;
            }
            #menuControls > select {
                padding-right: 24px !important;
            }
        }
        #planetSettingsButton {
            background: #2E8B57 !important;
            color: white !important;
            border: none !important;
        }
        
        #planetSettingsButton:hover {
            background: #3A9B63 !important;
        }
        .top-buttons-row button {
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            padding: 12px 20px;
            height: auto;
            min-height: 44px;
            line-height: 1.2;
            box-sizing: border-box;
        }
        @media (min-width: 768px) and (orientation: landscape) {
            .top-buttons-row {
                margin: 0 auto 5px !important;
            }
            
            #topControlsContainer {
                width: 100%;
                max-width: 640px;
                margin: 0 auto;
                display: flex;
                flex-direction: column;
                align-items: center;
            }

            .top-buttons-row {
                max-width: 100%;
                margin: 0 auto 5px !important;
                justify-content: center;
                width: 100%;
            }

            .setup-columns {
                max-width: 640px;
                margin: 0 auto;
                width: 100%;
            }

            #menuControls {
                max-width: 100%;
                margin: 5px auto;
                justify-content: center;
                width: 100%;
            }

            .top-buttons-row button {
                flex: 1;
                min-width: 0;
                max-width: 300px;
            }

            .setup-column {
                padding: 0 10px;
                box-sizing: border-box;
            }

            #menuControls > select,
            #menuControls > button {
                flex: 1;
                min-width: 0;
                max-width: 300px;
            }
            
            .top-buttons-row {
                gap: 12px;
            }
        }
        @media (max-width: 767px) {
            #topControlsContainer,
            .setup-columns {
                max-width: 300px;
                margin: 0 auto;
                width: 100%;
            }

            .top-buttons-row,
            #menuControls {
                width: 100%;
                max-width: 300px;
                margin-left: auto;
                margin-right: auto;
            }
            
            .top-buttons-row {
                flex-direction: column;
                width: 100%;
                max-width: 300px;
                margin: 0 auto 5px !important;
            }
            
            .top-buttons-row button {
                width: 100%;
                padding: 12px 15px !important;
            }
        }
        @media (max-width: 380px) {
            .top-buttons-row button {
                padding: 10px 12px !important;
                font-size: 16px;
            }
        }
        /* –°—Ç–∏–ª–∏ –¥–ª—è —Ä–µ–∂–∏–º–∞ –≤–≤–æ–¥–∞ –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç */
        .coord-input:focus {
            outline: none;
            border-color: #4CAF50 !important;
            box-shadow: 0 0 5px rgba(76, 175, 80, 0.5) !important;
        }
        .coord-input.invalid {
            border-color: #ff4444 !important;
            background: rgba(255, 68, 68, 0.1) !important;
        }
        .coord-input.valid {
            border-color: #4CAF50 !important;
            background: rgba(76, 175, 80, 0.1) !important;
        }
        .coord-input:hover {
            border-color: #777 !important;
        }
        #coordInputContainer {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            background: rgba(0, 0, 0, 0.9);
            color: white;
            padding: 12px;
            z-index: 1000;
            display: none;
            flex-direction: column;
            align-items: center;
            max-height: 40vh;
            overflow-y: auto;
            border-top: 2px solid #FFA500;
            box-shadow: 0 -2px 10px rgba(0,0,0,0.5);
        }
        #coordInputTitle {
            margin-bottom: 10px;
            font-weight: bold;
            text-align: center;
            font-size: 16px;
        }
        #coordRangeHint {
            font-size: 12px;
            color: #aaa;
            margin-bottom: 10px;
            text-align: center;
            padding: 6px;
            background: rgba(255,255,255,0.1);
            border-radius: 4px;
            max-width: 400px;
            line-height: 1.4;
        }
        #coordInputGroup {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 8px;
            margin-bottom: 12px;
        }
        .coord-input-wrapper {
            display: flex;
            flex-direction: column;
            align-items: center;
            position: relative;
        }
        .coord-input-wrapper label {
            font-size: 12px;
            margin-bottom: 4px;
            cursor: help;
            color: #ccc;
        }
        .coord-input {
            width: 90px;
            padding: 8px 6px;
            text-align: center;
            border: 1px solid #666;
            border-radius: 4px;
            background: #222;
            color: white;
            font-size: 14px;
            transition: all 0.2s;
        }
        @media (max-width: 600px) {
            #coordInputContainer {
                padding: 8px 5px !important;
            }
            .coord-input {
                width: 70px !important;
                font-size: 13px !important;
                padding: 5px 3px !important;
            }
            #coordRangeHint {
                font-size: 10px !important;
                padding: 3px !important;
            }
        }
        @media (max-width: 400px) {
            .coord-input {
                width: 60px !important;
                font-size: 12px !important;
            }
        }
    </style>
</head>
<body>
    <!-- –ì–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é -->
    <div id="setupScreen" class="menu-screen">
        <h1 id="mainTitle">–ì—Ä–∞–≤–∏—Ç–∞—Ü–∏–æ–Ω–Ω–∞—è –∏–≥—Ä–∞</h1>
        <div id="topControlsContainer">
            <div class="top-buttons-row">
                <button id="startButton">–ù–∞—á–∞—Ç—å –∏–≥—Ä—É</button>
                <button id="planetSettingsButton">–ù–∞—Å—Ç—Ä–æ–π–∫–∏</button>
            </div>
            <div id="menuControls"></div>
        </div>
        <div class="setup-columns">
            <div class="setup-column">
                <fieldset class="setup-group">
                    <legend id="gravityFunctionTypeLabel">–§—É–Ω–∫—Ü–∏—è –æ—Ç —Ä–∞—Å—Å—Ç–æ—è–Ω–∏—è:</legend>
                    <select id="gravityFunctionType">
                        <option value="1">–≠–∫—Å–ø–æ–Ω–µ–Ω—Ü–∏–∞–ª—å–Ω–∞—è: e^(‚àör / 4)</option>
                        <option value="2" selected>–ö–≤–∞–¥—Ä–∞—Ç–∏—á–Ω–∞—è (r¬≤)</option>
                        <option value="3">–õ–∏–Ω–µ–π–Ω–∞—è (r)</option>
                        <option value="4">–°—Ç–µ–ø–µ–Ω—å 3/2 (r^1.5)</option>
                        <option value="5">–≠–∫—Å–ø–æ–Ω–µ–Ω—Ü–∏–∞–ª—å–Ω–∞—è: e^(‚àõr)</option>
                    </select>
                </fieldset>
                <fieldset class="setup-group">
                    <legend id="planetCountLabel">–ö–æ–ª–∏—á–µ—Å—Ç–≤–æ –ø–ª–∞–Ω–µ—Ç (2‚Äì9):</legend>
                    <select id="planetCount">
                        <option value="2">2</option>
                        <option value="3">3</option>
                        <option value="4">4</option>
                        <option value="5">5</option>
                        <option value="6">6</option>
                        <option value="7" selected>7</option>
                        <option value="8">8</option>
                        <option value="9">9</option>
                    </select>
                </fieldset>
                <fieldset class="setup-group">
                    <legend id="startModeLabel">–†–µ–∂–∏–º —Å—Ç–∞—Ä—Ç–∞:</legend>
                    <select id="startMode">
                        <option value="2" selected>–°—Ç–∞—Ç–∏—á–Ω–æ–µ —Å–ª—É—á–∞–π–Ω–æ–µ</option>
                        <option value="3">–†—É—á–Ω–æ–π –≤–≤–æ–¥ (–ø–µ—Ä–µ—Ç–∞—Å–∫–∏–≤–∞–Ω–∏–µ)</option>
                        <option value="4">–†—É—á–Ω–æ–π –≤–≤–æ–¥ (–∫–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã)</option>
                    </select>
                </fieldset>
            </div>
            <div class="setup-column">
                <fieldset class="setup-group">
                    <legend id="collisionTypeLabel">–¢–∏–ø —Å—Ç–æ–ª–∫–Ω–æ–≤–µ–Ω–∏—è –ø–ª–∞–Ω–µ—Ç:</legend>
                    <select id="collisionType">
                        <option value="1">–£–ø—Ä—É–≥–æ–µ</option>
                        <option value="2" selected>–°—Ç–æ–ª–∫–Ω–æ–≤–µ–Ω–∏–µ —Ü–µ–Ω—Ç—Ä–æ–≤</option>
                        <option value="3">–ë–µ–∑ —Å—Ç–æ–ª–∫–Ω–æ–≤–µ–Ω–∏–π</option>
                    </select>
                </fieldset>
                <fieldset class="setup-group">
                    <legend id="boundaryTypeLabel">–ì—Ä–∞–Ω–∏—Ü—ã —ç–∫—Ä–∞–Ω–∞:</legend>
                    <select id="boundaryType">
                        <option value="2">–û—Ç—Ä–∞–∂–µ–Ω–∏–µ –æ—Ç –∫—Ä–∞–µ–≤</option>
                        <option value="1">–¢–æ—Ä–æ–∏–¥–∞–ª—å–Ω—ã–µ –≥—Ä–∞–Ω–∏—Ü—ã</option>
                        <option value="4" selected>–û–≥—Ä–∞–Ω–∏—á–µ–Ω–∏–µ –ø–æ —Ä–∞–¥–∏—É—Å—É</option>
                    </select>
                </fieldset>
            </div>
        </div>
        <div id="error" class="error"></div>
    </div>
    <!-- –≠–∫—Ä–∞–Ω –¥–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã—Ö –Ω–∞—Å—Ç—Ä–æ–µ–∫ -->
    <div id="SettingsScreen" class="menu-screen">
        <h1 id="settingsTitle">–ù–∞—Å—Ç—Ä–æ–π–∫–∏</h1>
        <button id="openPlanetEdit">–ù–∞—Å—Ç—Ä–æ–π–∫–∏ –ø–ª–∞–Ω–µ—Ç</button>
        <div class="planet-settings-advanced">
            <fieldset class="setup-group">
                <legend id="radiusLabel">–†–∞–¥–∏—É—Å –ø–ª–∞–Ω–µ—Ç (5‚Äì65):</legend>
                <input type="number" id="planetRadius" min="5" max="65" value="40">
            </fieldset>
            <fieldset class="setup-group">
                <legend id="maxForceLabel">–ú–∞–∫—Å. —Å–∏–ª–∞ –ø—Ä–∏—Ç—è–∂–µ–Ω–∏—è (1 M-100 M):</legend>
                <input type="number" id="maxGravitationalForce" min="1000000" max="100000000" step="1000000" value="5000000">
            </fieldset>
            <fieldset class="setup-group">
                <legend id="centralMassLabel">–ú–∞—Å—Å–∞ —Ü–µ–Ω—Ç—Ä–∞ (0‚Äì10 000 000):</legend>
                <input type="number" id="centralMass" min="0" max="10000000" step="10000" value="100000">
            </fieldset>
            <fieldset class="setup-group">
                <legend id="usePrecomputedTableLabel">–¢–∞–±–ª–∏—Ü–∞ –¥–ª—è —ç–∫—Å–ø–æ–Ω–µ–Ω—Ü–∏–∞–ª—å–Ω–æ–π —Ñ—É–Ω–∫—Ü–∏–∏</legend>
                <input type="checkbox" id="usePrecomputedTable" checked>
            </fieldset>
            <fieldset class="setup-group">
                <legend id="gravityConstantLabel">–ì—Ä–∞–≤–∏—Ç–∞—Ü–∏–æ–Ω–Ω–∞—è –ø–æ—Å—Ç–æ—è–Ω–Ω–∞—è:</legend>
                <input type="number" id="gravityConstant" step="1" value="200">
            </fieldset>
            <fieldset class="setup-group">
                <legend id="massMultiplierLabel">–û–±—â–∏–π –º–Ω–æ–∂–∏—Ç–µ–ª—å –º–∞—Å—Å –ø–ª–∞–Ω–µ—Ç:</legend>
                <input type="number" id="planetMassMultiplier" min="0.1" max="10" step="0.1" value="1.0">
            </fieldset>
            <fieldset class="setup-group">
                <legend id="maxSpeedLabel">–ú–∞–∫—Å–∏–º–∞–ª—å–Ω–∞—è —Å–∫–æ—Ä–æ—Å—Ç—å (–ø–∏–∫—Å./—Å–µ–∫):</legend>
                <input type="number" id="maxPlanetSpeed" min="400" max="3000" step="100" value="700">
            </fieldset>
        </div>
        <button id="backFromSettings">–ù–∞–∑–∞–¥</button>
    </div>
    <!-- –≠–∫—Ä–∞–Ω –∏–Ω–¥–∏–≤–∏–¥—É–∞–ª—å–Ω—ã—Ö –Ω–∞—Å—Ç—Ä–æ–µ–∫ –ø–ª–∞–Ω–µ—Ç -->
    <div id="IndividualPlanetSettingsScreen" class="menu-screen">
        <h1 id="planetSettingsTitle">–ò–Ω–¥–∏–≤–∏–¥—É–∞–ª—å–Ω—ã–µ –Ω–∞—Å—Ç—Ä–æ–π–∫–∏ –ø–ª–∞–Ω–µ—Ç</h1>
        <div id="planetSettingsContainer">
        </div>
        <button id="backFromIndividualPlanet">–ù–∞–∑–∞–¥</button>
    </div>
    <!-- –ö–æ–Ω—Ç–µ–π–Ω–µ—Ä –¥–ª—è –≤–≤–æ–¥–∞ –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç -->
    <div id="coordInputContainer">
        <div id="coordInputTitle">–í–≤–æ–¥ –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç: –ü–ª–∞–Ω–µ—Ç–∞ 1 –∏–∑ 7</div>
        <div id="coordRangeHint"></div>
        <div id="coordInputGroup">
            <div class="coord-input-wrapper">
                <label for="coordStartX">–°—Ç–∞—Ä—Ç X:</label>
                <input type="number" id="coordStartX" class="coord-input" data-index="0">
            </div>
            <div class="coord-input-wrapper">
                <label for="coordStartY">–°—Ç–∞—Ä—Ç Y:</label>
                <input type="number" id="coordStartY" class="coord-input" data-index="1">
            </div>
            <div class="coord-input-wrapper">
                <label for="coordEndX">–ö–æ–Ω–µ—Ü X:</label>
                <input type="number" id="coordEndX" class="coord-input" data-index="2">
            </div>
            <div class="coord-input-wrapper">
                <label for="coordEndY">–ö–æ–Ω–µ—Ü Y:</label>
                <input type="number" id="coordEndY" class="coord-input" data-index="3">
            </div>
        </div>
        <div style="display: flex; gap: 10px; flex-wrap: wrap; justify-content: center;">
            <button id="coordConfirmBtn" style="padding: 10px 18px; background: #4CAF50; color: white; border: none; border-radius: 5px; cursor: pointer; font-size: 14px; font-weight: bold;">–ü–æ–¥—Ç–≤–µ—Ä–¥–∏—Ç—å –ø–ª–∞–Ω–µ—Ç—É</button>
            <button id="coordResetBtn" style="padding: 10px 18px; background: #f44336; color: white; border: none; border-radius: 5px; cursor: pointer; font-size: 14px;">–°–±—Ä–æ—Å–∏—Ç—å</button>
            <button id="coordCancelBtn" style="padding: 10px 18px; background: #777; color: white; border: none; border-radius: 5px; cursor: pointer; font-size: 14px;">–û—Ç–º–µ–Ω–∞</button>
        </div>
    </div>
    <!-- –ò–Ω–¥–∏–∫–∞—Ç–æ—Ä —Ä—É—á–Ω–æ–≥–æ —Ä–µ–∂–∏–º–∞ -->
    <div id="manualModeIndicator" class="manual-mode-indicator"></div>
    <!-- Canvas –∏–≥—Ä—ã -->
    <canvas id="gameCanvas"></canvas>
    <!-- –ú–æ–¥–∞–ª—å–Ω—ã–µ –æ–∫–Ω–∞ -->
    <div id="aboutOverlay" class="modal-overlay" style="display: none;">
        <div class="about-modal-content">
            <h2 id="aboutTitle"></h2>
            <p id="aboutAuthor"></p>
            <p id="aboutYear"></p>
            <p id="aboutLicense"></p>
            <div class="about-description-block">
                <p id="aboutDescription"></p>
            </div>
            <div class="about-buttons">
                <button id="licenseBtn" class="secondary-btn"></button>
                <button id="licenseOnlineBtn" class="secondary-btn"></button>
            </div>
            <div class="about-footer">
                <button id="closeAboutBtn" class="primary-btn"></button>
            </div>
        </div>
    </div>
    <div id="licenseOverlay" class="modal-overlay" style="display: none;">
        <div class="license-modal-content">
            <h3 id="licenseModalTitle"></h3>
            <pre id="licenseText"></pre>
            <div class="modal-footer">
                <button id="closeLicenseBtn" class="secondary-btn"></button>
            </div>
        </div>
    </div>
    <div id="offlineOverlay" class="modal-overlay" style="display: none;">
        <div class="offline-modal-content">
            <h3 id="offlineTitle"></h3>
            <p><strong id="offlineReasonLabel"></strong> <span id="offlineReasonText"></span></p>
            <div class="offline-instructions">
                <h4 id="offlineInstructions"></h4>
                <ol>
                    <li id="offlineStep1"></li>
                    <li id="offlineStep2"></li>
                    <li id="offlineStep3"></li>
                </ol>
            </div>
            <p class="offline-link">
                <strong id="orVisit"></strong><br>
                <a href="https://www.gnu.org/licenses/agpl-3.0.txt" target="_blank" rel="noopener">
                    <span id="gnuLicenseText"></span>
                </a>
            </p>
            <div class="modal-footer">
                <button id="closeInstructionBtn" class="primary-btn"></button>
            </div>
        </div>
    </div>
    <script>
        // === –ú–µ—Ç–∞–¥–∞–Ω–Ω—ã–µ –∏ —Å–∏—Å—Ç–µ–º–∞ –ª–æ–∫–∞–ª–∏–∑–∞—Ü–∏–∏ ===
        const APP_METADATA = {
            version: "1.0",
            author: "ant3mc",
            year: "2025",
            license: "GNU AGPL-3.0-or-later"
        };
        const translations = {
            ru: {
                appTitle: "–ì—Ä–∞–≤–∏—Ç–∞—Ü–∏–æ–Ω–Ω–∞—è –ø–µ—Å–æ—á–Ω–∏—Ü–∞",
                usePrecomputedTableLabel: "–¢–∞–±–ª–∏—Ü–∞ –¥–ª—è —ç–∫—Å–ø–æ–Ω–µ–Ω—Ü–∏–∞–ª—å–Ω–æ–π —Ñ—É–Ω–∫—Ü–∏–∏",
                settingsBtn: "–ù–∞—Å—Ç—Ä–æ–π–∫–∏",
                planetSettingsBtn: "–ù–∞—Å—Ç—Ä–æ–π–∫–∏ –ø–ª–∞–Ω–µ—Ç",
                aboutBtn: "–û –ø—Ä–æ–≥—Ä–∞–º–º–µ",
                startBtn: "–ù–∞—á–∞—Ç—å –∏–≥—Ä—É",
                backBtn: "–ù–∞–∑–∞–¥",
                closeBtn: "–ó–∞–∫—Ä—ã—Ç—å",
                showLicenseBtn: "üìÑ –ü–æ–∫–∞–∑–∞—Ç—å –ø–æ–ª–Ω—É—é –ª–∏—Ü–µ–Ω–∑–∏—é",
                openLicenseOnlineBtn: "üåê –û—Ç–∫—Ä—ã—Ç—å –Ω–∞ gnu.org",
                understandBtn: "–ü–æ–Ω—è—Ç–Ω–æ",
                methodLabel: "–§—É–Ω–∫—Ü–∏—è –æ—Ç —Ä–∞—Å—Å—Ç–æ—è–Ω–∏—è",
                planetCountLabel: "–ö–æ–ª–∏—á–µ—Å—Ç–≤–æ –ø–ª–∞–Ω–µ—Ç (2‚Äì9)",
                startModeLabel: "–†–µ–∂–∏–º —Å—Ç–∞—Ä—Ç–∞",
                collisionLabel: "–¢–∏–ø —Å—Ç–æ–ª–∫–Ω–æ–≤–µ–Ω–∏—è –ø–ª–∞–Ω–µ—Ç",
                boundaryLabel: "–ì—Ä–∞–Ω–∏—Ü—ã —ç–∫—Ä–∞–Ω–∞",
                radiusLabel: "–†–∞–¥–∏—É—Å –ø–ª–∞–Ω–µ—Ç (5‚Äì65)",
                maxForceLabel: "–ú–∞–∫—Å. —Å–∏–ª–∞ –ø—Ä–∏—Ç—è–∂–µ–Ω–∏—è (1 M-100 M)",
                centralMassLabel: "–ú–∞—Å—Å–∞ —Ü–µ–Ω—Ç—Ä–∞ (0‚Äì10 000 000)",
                gravityConstantLabel: "–ì—Ä–∞–≤–∏—Ç–∞—Ü–∏–æ–Ω–Ω–∞—è –ø–æ—Å—Ç–æ—è–Ω–Ω–∞—è",
                massMultiplierLabel: "–û–±—â–∏–π –º–Ω–æ–∂–∏—Ç–µ–ª—å –º–∞—Å—Å –ø–ª–∞–Ω–µ—Ç",
                maxSpeedLabel: "–ú–∞–∫—Å–∏–º–∞–ª—å–Ω–∞—è —Å–∫–æ—Ä–æ—Å—Ç—å (–ø–∏–∫—Å./—Å–µ–∫)",
                settingsTitle: "–ù–∞—Å—Ç—Ä–æ–π–∫–∏",
                planetSettingsTitle: "–ò–Ω–¥–∏–≤–∏–¥—É–∞–ª—å–Ω—ã–µ –Ω–∞—Å—Ç—Ä–æ–π–∫–∏ –ø–ª–∞–Ω–µ—Ç",
                aboutTitle: "–ì—Ä–∞–≤–∏—Ç–∞—Ü–∏–æ–Ω–Ω–∞—è –ø–µ—Å–æ—á–Ω–∏—Ü–∞ v1",
                author: "–ê–≤—Ç–æ—Ä",
                year: "–ì–æ–¥",
                license: "–õ–∏—Ü–µ–Ω–∑–∏—è",
                aboutDescription: "–≠—Ç–æ —Å–≤–æ–±–æ–¥–Ω–æ–µ –ø—Ä–æ–≥—Ä–∞–º–º–Ω–æ–µ –æ–±–µ—Å–ø–µ—á–µ–Ω–∏–µ. –í—ã –º–æ–∂–µ—Ç–µ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å, –∏–∑–º–µ–Ω—è—Ç—å –∏ —Ä–∞—Å–ø—Ä–æ—Å—Ç—Ä–∞–Ω—è—Ç—å –µ–≥–æ –Ω–∞ —É—Å–ª–æ–≤–∏—è—Ö –ª–∏—Ü–µ–Ω–∑–∏–∏ AGPL-3.0-or-later.",
                errorTitle: "–û—à–∏–±–∫–∞",
                loadingText: "–ó–∞–≥—Ä—É–∑–∫–∞",
                offlineTitle: "‚ö†Ô∏è –ù–µ —É–¥–∞–ª–æ—Å—å –∑–∞–≥—Ä—É–∑–∏—Ç—å –ª–∏—Ü–µ–Ω–∑–∏—é –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏",
                offlineReasonFile: "–ó–∞–ø—É—â–µ–Ω–æ –∏–∑ –ª–æ–∫–∞–ª—å–Ω–æ–≥–æ —Ñ–∞–π–ª–∞. –ë—Ä–∞—É–∑–µ—Ä –±–ª–æ–∫–∏—Ä—É–µ—Ç –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏–π –¥–æ—Å—Ç—É–ø.",
                offlineReasonOffline: "–û—Ç—Å—É—Ç—Å—Ç–≤—É–µ—Ç –ø–æ–¥–∫–ª—é—á–µ–Ω–∏–µ –∫ –∏–Ω—Ç–µ—Ä–Ω–µ—Ç—É.",
                offlineReasonGeneric: "–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏",
                offlineInstructions: "–ß—Ç–æ–±—ã –ø–æ—Å–º–æ—Ç—Ä–µ—Ç—å –ª–∏—Ü–µ–Ω–∑–∏—é:",
                offlineStep1: "–û—Ç–∫—Ä–æ–π—Ç–µ –ø–∞–ø–∫—É (–ø–æ–ª—É—á–µ–Ω–Ω—É—é –∏–∑ —Å–∫–∞—á–µ–Ω–Ω–æ–≥–æ –∞—Ä—Ö–∏–≤–∞) —Å —ç—Ç–∏–º —Ñ–∞–π–ª–æ–º",
                offlineStep2: "–ù–∞–π–¥–∏—Ç–µ —Ñ–∞–π–ª LICENSE",
                offlineStep3: "–û—Ç–∫—Ä–æ–π—Ç–µ –µ–≥–æ –≤ —Ç–µ–∫—Å—Ç–æ–≤–æ–º —Ä–µ–¥–∞–∫—Ç–æ—Ä (Notepad, VS Code –∏ —Ç.–¥.)",
                orVisit: "–ò–ª–∏ –ø–æ—Å–µ—Ç–∏—Ç–µ –æ—Ñ–∏—Ü–∏–∞–ª—å–Ω—É—é –≤–µ—Ä—Å–∏—é:",
                gnuLicenseText: "gnu.org/licenses/agpl-3.0.txt",
                doubleClickHint: "–î–≤–æ–π–Ω–æ–π –∫–ª–∏–∫ –¥–ª—è –≤—ã—Ö–æ–¥–∞",
                manualModePlacePlanet: (current, total) => `–†–∞–∑–º–µ—Å—Ç–∏—Ç–µ –ø–ª–∞–Ω–µ—Ç—É ${current} / ${total}`,
                manualModeInvalidPosition: "–°–ª–∏—à–∫–æ–º –±–ª–∏–∑–∫–æ –∫ –¥—Ä—É–≥–∏–º –ø–ª–∞–Ω–µ—Ç–∞–º!",
                manualModeCoordinatePlace: (current, total) => `–í–≤–æ–¥ –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç –ø–ª–∞–Ω–µ—Ç—ã ${current} / ${total}`,
                coordStartXHint: (maxX) => `X-–∫–æ–æ—Ä–¥–∏–Ω–∞—Ç–∞ –Ω–∞—á–∞–ª–∞ (¬±${maxX})`,
                coordStartYHint: (maxY) => `Y-–∫–æ–æ—Ä–¥–∏–Ω–∞—Ç–∞ –Ω–∞—á–∞–ª–∞ (¬±${maxY})`,
                coordEndXHint: (maxX) => `X-–∫–æ–æ—Ä–¥–∏–Ω–∞—Ç–∞ –∫–æ–Ω—Ü–∞ (¬±${maxX})`,
                coordEndYHint: (maxY) => `Y-–∫–æ–æ—Ä–¥–∏–Ω–∞—Ç–∞ –∫–æ–Ω—Ü–∞ (¬±${maxY})`,
                coordRangeHint: (maxX, maxY) => `–î–æ–ø—É—Å—Ç–∏–º—ã–π –¥–∏–∞–ø–∞–∑–æ–Ω: X: ¬±${maxX}, Y: ¬±${maxY}`,
                coordMinDistance: (minDist) => `–ú–∏–Ω–∏–º–∞–ª—å–Ω–æ–µ —Ä–∞—Å—Å—Ç–æ—è–Ω–∏–µ: ${minDist}px`,
                coordCurrentRadius: (radius) => `–¢–µ–∫—É—â–∏–π —Ä–∞–¥–∏—É—Å: ${radius}px`,
                coordValidationError: (min, max) => `–ó–Ω–∞—á–µ–Ω–∏–µ –¥–æ–ª–∂–Ω–æ –±—ã—Ç—å –º–µ–∂–¥—É ${min} –∏ ${max}`,
                coordValidValue: "‚úì –ó–Ω–∞—á–µ–Ω–∏–µ –≤ –¥–æ–ø—É—Å—Ç–∏–º–æ–º –¥–∏–∞–ø–∞–∑–æ–Ω–µ",
                coordEnterNumber: "–í–≤–µ–¥–∏—Ç–µ —á–∏—Å–ª–æ–≤–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ",
                coordFixFields: "–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –∏—Å–ø—Ä–∞–≤—å—Ç–µ –≤—ã–¥–µ–ª–µ–Ω–Ω—ã–µ –ø–æ–ª—è",
                methodOptions: {
                    '1': "–≠–∫—Å–ø–æ–Ω–µ–Ω—Ü–∏–∞–ª—å–Ω–∞—è: e^(‚àör / 4)",
                    '2': "–ö–≤–∞–¥—Ä–∞—Ç–∏—á–Ω–∞—è (r¬≤)",
                    '3': "–õ–∏–Ω–µ–π–Ω–∞—è (r)",
                    '4': "–°—Ç–µ–ø–µ–Ω—å 3/2 (r^1.5)",
                    '5': "–≠–∫—Å–ø–æ–Ω–µ–Ω—Ü–∏–∞–ª—å–Ω–∞—è: e^(‚àõr)"
                },
                startModeOptions: {
                    '2': "–°—Ç–∞—Ç–∏—á–Ω–æ–µ —Å–ª—É—á–∞–π–Ω–æ–µ",
                    '3': "–†—É—á–Ω–æ–π –≤–≤–æ–¥ (–ø–µ—Ä–µ—Ç–∞—Å–∫–∏–≤–∞–Ω–∏–µ)",
                    '4': "–†—É—á–Ω–æ–π –≤–≤–æ–¥ (–∫–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã)"
                },
                collisionOptions: {
                    '1': "–£–ø—Ä—É–≥–æ–µ",
                    '2': "–°—Ç–æ–ª–∫–Ω–æ–≤–µ–Ω–∏–µ —Ü–µ–Ω—Ç—Ä–æ–≤",
                    '3': "–ë–µ–∑ —Å—Ç–æ–ª–∫–Ω–æ–≤–µ–Ω–∏–π"
                },
                boundaryOptions: {
                    '1': "–¢–æ—Ä–æ–∏–¥–∞–ª—å–Ω—ã–µ –≥—Ä–∞–Ω–∏—Ü—ã",
                    '2': "–û—Ç—Å–∫–æ–∫ –æ—Ç —Å—Ç–µ–Ω",
                    '4': "–û–≥—Ä–∞–Ω–∏—á–µ–Ω–∏–µ –ø–æ —Ä–∞–¥–∏—É—Å—É"
                },
                licenseModalTitle: "GNU Affero General Public License v3.0"
            },
            en: {
                appTitle: "Gravity Sandbox",
                usePrecomputedTableLabel: "Precomputed table for exponential function",
                settingsBtn: "Settings",
                planetSettingsBtn: "Planet Settings",
                aboutBtn: "About",
                startBtn: "Start Game",
                backBtn: "Back",
                closeBtn: "Close",
                showLicenseBtn: "üìÑ Show Full License",
                openLicenseOnlineBtn: "üåê Open on gnu.org",
                understandBtn: "OK",
                methodLabel: "Distance Function",
                planetCountLabel: "Number of Planets (2-9)",
                startModeLabel: "Start Mode",
                collisionLabel: "Collision Type",
                boundaryLabel: "Screen Boundaries",
                radiusLabel: "Planet Radius (5-65)",
                maxForceLabel: "Max Gravitational Force (1,000,000-100,000,000)",
                centralMassLabel: "Central Mass (0-10,000,000)",
                gravityConstantLabel: "Gravitational Constant",
                massMultiplierLabel: "Planet Mass Multiplier",
                maxSpeedLabel: "Maximum Speed (px/sec)",
                settingsTitle: "Settings",
                planetSettingsTitle: "Individual Planet Settings",
                aboutTitle: "Gravity Sandbox v1",
                author: "Author",
                year: "Year",
                license: "License",
                aboutDescription: "This is free software. You can use, modify and distribute it under the terms of AGPL-3.0-or-later.",
                errorTitle: "Error",
                loadingText: "Loading",
                offlineTitle: "‚ö†Ô∏è Could not load license automatically",
                offlineReasonFile: "Running from local file. Browser blocks automatic access.",
                offlineReasonOffline: "No internet connection.",
                offlineReasonGeneric: "Load error",
                offlineInstructions: "To view the license:",
                offlineStep1: "Open the folder (extracted from the downloaded archive) with this file",
                offlineStep2: "Find the LICENSE file",
                offlineStep3: "Open it in a text editor (Notepad, VS Code, etc.)",
                orVisit: "Or visit the official version:",
                gnuLicenseText: "gnu.org/licenses/agpl-3.0.txt",
                doubleClickHint: "Double-click to exit",
                manualModePlacePlanet: (current, total) => `Place planet ${current} / ${total}`,
                manualModeInvalidPosition: "Too close to other planets!",
                manualModeCoordinatePlace: (current, total) => `Input coordinates planet ${current} / ${total}`,
                coordStartXHint: (maxX) => `Start X coordinate (¬±${maxX})`,
                coordStartYHint: (maxY) => `Start Y coordinate (¬±${maxY})`,
                coordEndXHint: (maxX) => `End X coordinate (¬±${maxX})`,
                coordEndYHint: (maxY) => `End Y coordinate (¬±${maxY})`,
                coordRangeHint: (maxX, maxY) => `Allowed range: X: ¬±${maxX}, Y: ¬±${maxY}`,
                coordMinDistance: (minDist) => `Minimum distance: ${minDist}px`,
                coordCurrentRadius: (radius) => `Current radius: ${radius}px`,
                coordValidationError: (min, max) => `Value must be between ${min} and ${max}`,
                coordValidValue: "‚úì Value in allowed range",
                coordEnterNumber: "Enter a numeric value",
                coordFixFields: "Please correct highlighted fields",
                methodOptions: {
                    '1': "Exponential: e^(‚àör / 4)",
                    '2': "Quadratic (r¬≤)",
                    '3': "Linear (r)",
                    '4': "Power 3/2 (r^1.5)",
                    '5': "Exponential: e^(‚àõr)"
                },
                startModeOptions: {
                    '2': "Random Static",
                    '3': "Manual Input (drag)",
                    '4': "Manual Input (coordinates)"
                },
                collisionOptions: {
                    '1': "Elastic",
                    '2': "Center Collision",
                    '3': "No Collisions"
                },
                boundaryOptions: {
                    '1': "Toroidal Boundaries",
                    '2': "Bounce Off Edges",
                    '4': "Radius Limit"
                },
                licenseModalTitle: "GNU Affero General Public License v3.0"
            }
        };

        // === –ú–µ–Ω–µ–¥–∂–µ—Ä –Ω–∞—Å—Ç—Ä–æ–µ–∫ ===
        const DEFAULT_COLORS = [
            '#FF0000', '#00FF00', '#0000FF', '#FFFF00', '#FF00FF',
            '#00FFFF', '#FF8000', '#8000FF', '#FF0080', '#00FF80',
            '#80FF00', '#0080FF', '#FF4500', '#9400D3', '#00FA9A', '#40E0D0'
        ];

        class SettingsManager {
            constructor() {
                this.settingsKey = 'gravi-settings';
                this.defaultSettings = {
                    planetColors: DEFAULT_COLORS.slice(0, 9),
                    planetRadius: 40,
                    maxGravitationalForce: 5000000,
                    maxPlanetSpeed: 700
                };
            }

            load() {
                try {
                    const saved = localStorage.getItem(this.settingsKey);
                    if (saved) {
                        const parsed = JSON.parse(saved);
                        return {...this.defaultSettings, ...parsed};
                    }
                } catch (e) {
                    console.warn('Failed to load settings:', e);
                }
                return {...this.defaultSettings};
            }

            save(settings) {
                try {
                    const dataToSave = {
                        planetColors: settings.planetColors || this.defaultSettings.planetColors,
                        planetRadius: settings.planetRadius || this.defaultSettings.planetRadius,
                        maxGravitationalForce: settings.maxGravitationalForce || this.defaultSettings.maxGravitationalForce,
                        maxPlanetSpeed: settings.maxPlanetSpeed || this.defaultSettings.maxPlanetSpeed
                    };
                    localStorage.setItem(this.settingsKey, JSON.stringify(dataToSave));
                } catch (e) {
                    console.warn('Failed to save settings:', e);
                }
            }

            getCurrentUISettings() {
                return {
                    planetColors: this.getPlanetColorsFromUI(),
                    planetRadius: parseFloat(document.getElementById('planetRadius').value) || 40,
                    maxGravitationalForce: parseFloat(document.getElementById('maxGravitationalForce').value) || 5000000,
                    maxPlanetSpeed: parseFloat(document.getElementById('maxPlanetSpeed').value) || 700
                };
            }

            getPlanetColorsFromUI() {
                const colors = [];
                for (let i = 1; i <= 9; i++) {
                    const colorSelect = document.getElementById(`color${i}`);
                    if (colorSelect) {
                        colors.push(colorSelect.value);
                    } else {
                        colors.push(DEFAULT_COLORS[i - 1] || '#FF0000');
                    }
                }
                return colors;
            }

            applyToUI() {
                const settings = this.load();
                
                document.getElementById('planetRadius').value = settings.planetRadius;
                document.getElementById('maxGravitationalForce').value = settings.maxGravitationalForce;
                document.getElementById('maxPlanetSpeed').value = settings.maxPlanetSpeed;

                for (let i = 1; i <= 9; i++) {
                    const colorSelect = document.getElementById(`color${i}`);
                    const preview = document.getElementById(`preview${i}`);
                    if (colorSelect && preview && settings.planetColors[i - 1]) {
                        colorSelect.value = settings.planetColors[i - 1];
                        preview.style.background = settings.planetColors[i - 1];
                    }
                }
            }
        }

        const settingsManager = new SettingsManager();

        class LocalizationManager {
            constructor() {
                try {
                    this.currentLanguage = localStorage.getItem('gravi-language') || 'en';
                } catch (e) {
                    this.currentLanguage = 'en';
                }
            }
            t(key, ...args) {
                const value = translations[this.currentLanguage][key];
                if (typeof value === 'function') {
                    return value(...args);
                }
                return value || key;
            }
            setLanguage(lang) {
                this.currentLanguage = lang;
                try {
                    localStorage.setItem('gravi-language', lang);
                } catch (e) {
                    console.warn('localStorage not available');
                }
                this.updateUI();
            }
            createLanguageSelector() {
                const selector = document.createElement('select');
                selector.id = 'languageSelect';
                selector.innerHTML = `
                    <option value="ru">üá∑üá∫ –†—É—Å—Å–∫–∏–π</option>
                    <option value="en">üá¨üáß English</option>
                `;
                selector.value = this.currentLanguage;
                selector.addEventListener('change', (e) => this.setLanguage(e.target.value));
                return selector;
            }
            updateUI() {
                document.getElementById('mainTitle').textContent = this.t('appTitle');
                document.getElementById('settingsTitle').textContent = this.t('settingsTitle');
                document.getElementById('planetSettingsTitle').textContent = this.t('planetSettingsTitle');
                this.updateLabel('gravityFunctionTypeLabel', 'methodLabel');
                this.updateLabel('planetCountLabel', 'planetCountLabel');
                this.updateLabel('startModeLabel', 'startModeLabel');
                this.updateLabel('collisionTypeLabel', 'collisionLabel');
                this.updateLabel('boundaryTypeLabel', 'boundaryLabel');
                this.updateLabel('radiusLabel', 'radiusLabel');
                this.updateLabel('maxForceLabel', 'maxForceLabel');
                this.updateLabel('centralMassLabel', 'centralMassLabel');
                this.updateLabel('gravityConstantLabel', 'gravityConstantLabel');
                this.updateLabel('massMultiplierLabel', 'massMultiplierLabel');
                this.updateLabel('maxSpeedLabel', 'maxSpeedLabel');
                this.updateLabel('usePrecomputedTableLabel', 'usePrecomputedTableLabel');
                this.updateSelectOptions('gravityFunctionType', 'methodOptions');
                this.updateSelectOptions('startMode', 'startModeOptions');
                this.updateSelectOptions('collisionType', 'collisionOptions');
                this.updateSelectOptions('boundaryType', 'boundaryOptions');
                const startBtn = document.getElementById('startButton');
                if (startBtn) startBtn.textContent = this.t('startBtn');
                const settingsBtn = document.getElementById('planetSettingsButton');
                if (settingsBtn) settingsBtn.textContent = this.t('settingsBtn');
                const aboutBtn = document.getElementById('aboutButton');
                if (aboutBtn) aboutBtn.textContent = this.t('aboutBtn');
                const openPlanetEdit = document.getElementById('openPlanetEdit');
                if (openPlanetEdit) openPlanetEdit.textContent = this.t('planetSettingsBtn');
                const backBtns = ['backFromSettings', 'backFromIndividualPlanet'];
                backBtns.forEach(id => {
                    const btn = document.getElementById(id);
                    if (btn) btn.textContent = this.t('backBtn');
                });
                document.getElementById('aboutTitle').textContent = this.t('aboutTitle');
                document.getElementById('aboutAuthor').innerHTML = `<strong>${this.t('author')}:</strong> ${APP_METADATA.author}`;
                document.getElementById('aboutYear').innerHTML = `<strong>${this.t('year')}:</strong> ${APP_METADATA.year}`;
                document.getElementById('aboutLicense').innerHTML = `<strong>${this.t('license')}:</strong> ${APP_METADATA.license}`;
                document.getElementById('aboutDescription').textContent = this.t('aboutDescription');
                document.getElementById('licenseBtn').textContent = this.t('showLicenseBtn');
                document.getElementById('licenseOnlineBtn').textContent = this.t('openLicenseOnlineBtn');
                document.getElementById('closeAboutBtn').textContent = this.t('backBtn');
                document.getElementById('licenseModalTitle').textContent = this.t('licenseModalTitle');
                document.getElementById('closeLicenseBtn').textContent = this.t('closeBtn');
                document.getElementById('offlineTitle').textContent = this.t('offlineTitle');
                document.getElementById('offlineReasonLabel').textContent = this.t('offlineReasonGeneric') + ':';
                document.getElementById('offlineReasonText').textContent = this.t('offlineReasonFile');
                document.getElementById('offlineInstructions').textContent = this.t('offlineInstructions');
                document.getElementById('offlineStep1').textContent = this.t('offlineStep1');
                document.getElementById('offlineStep2').textContent = this.t('offlineStep2');
                document.getElementById('offlineStep3').textContent = this.t('offlineStep3');
                document.getElementById('orVisit').textContent = this.t('orVisit');
                document.getElementById('gnuLicenseText').textContent = this.t('gnuLicenseText');
                document.getElementById('closeInstructionBtn').textContent = this.t('understandBtn');
            }
            updateLabel(elementId, key) {
                const element = document.getElementById(elementId);
                if (element) element.textContent = this.t(key);
            }
            updateSelectOptions(selectId, optionsKey) {
                const select = document.getElementById(selectId);
                if (!select) return;
                const currentValue = select.value;
                const options = translations[this.currentLanguage][optionsKey];
                select.innerHTML = '';
                for (const [value, text] of Object.entries(options)) {
                    const option = document.createElement('option');
                    option.value = value;
                    option.textContent = text;
                    if (value === currentValue) option.selected = true;
                    select.appendChild(option);
                }
            }
            initMenuUI() {
                const controlsContainer = document.getElementById('topControlsContainer');
                const controlsWrapper = document.createElement('div');
                controlsWrapper.id = 'menuControls';
                const langSelector = this.createLanguageSelector();
                controlsWrapper.appendChild(langSelector);
                const aboutBtn = document.createElement('button');
                aboutBtn.id = 'aboutButton';
                aboutBtn.textContent = this.t('aboutBtn');
                controlsWrapper.appendChild(aboutBtn);
                controlsContainer.appendChild(controlsWrapper);
                this.bindAboutModal();
                this.updateUI();
                
                // –ó–∞–≥—Ä—É–∂–∞–µ–º —Å–æ—Ö—Ä–∞–Ω–µ–Ω–Ω—ã–µ –Ω–∞—Å—Ç—Ä–æ–π–∫–∏
                settingsManager.applyToUI();
                
                aboutBtn.addEventListener('click', () => {
                    this.showAboutModal();
                });
            }
            bindAboutModal() {
                document.getElementById('closeAboutBtn').addEventListener('click', () => {
                    this.hideAboutModal();
                });
                document.getElementById('licenseBtn').addEventListener('click', async () => {
                    await this.loadLicense();
                });
                document.getElementById('licenseOnlineBtn').addEventListener('click', () => {
                    window.open('https://www.gnu.org/licenses/agpl-3.0.txt', '_blank', 'noopener,noreferrer');
                });
                document.getElementById('closeLicenseBtn').addEventListener('click', () => {
                    this.hideLicenseModal();
                });
                document.getElementById('closeInstructionBtn').addEventListener('click', () => {
                    this.hideOfflineModal();
                });
                document.getElementById('aboutOverlay').addEventListener('click', (e) => {
                    if (e.target.id === 'aboutOverlay') this.hideAboutModal();
                });
                document.getElementById('licenseOverlay').addEventListener('click', (e) => {
                    if (e.target.id === 'licenseOverlay') this.hideLicenseModal();
                });
                document.getElementById('offlineOverlay').addEventListener('click', (e) => {
                    if (e.target.id === 'offlineOverlay') this.hideOfflineModal();
                });
            }
            showAboutModal() {
                document.getElementById('setupScreen').style.display = 'none';
                document.getElementById('aboutOverlay').style.display = 'flex';
            }
            hideAboutModal() {
                document.getElementById('aboutOverlay').style.display = 'none';
                document.getElementById('setupScreen').style.display = 'flex';
            }
            showLicenseModal(licenseText) {
                document.getElementById('licenseText').textContent = licenseText;
                document.getElementById('licenseOverlay').style.display = 'flex';
                document.getElementById('aboutOverlay').style.display = 'none';
            }
            hideLicenseModal() {
                document.getElementById('licenseOverlay').style.display = 'none';
                document.getElementById('aboutOverlay').style.display = 'flex';
            }
            showOfflineInstructions(errorMessage) {
                const isFileProtocol = window.location.protocol === 'file:';
                const isOffline = !navigator.onLine;
                let reason = '';
                if (isFileProtocol) {
                    reason = this.t('offlineReasonFile');
                } else if (isOffline) {
                    reason = this.t('offlineReasonOffline');
                } else {
                    reason = `${this.t('offlineReasonGeneric')}: ${errorMessage}`;
                }
                document.getElementById('offlineReasonText').textContent = reason;
                document.getElementById('offlineOverlay').style.display = 'flex';
                document.getElementById('aboutOverlay').style.display = 'none';
            }
            hideOfflineModal() {
                document.getElementById('offlineOverlay').style.display = 'none';
                document.getElementById('aboutOverlay').style.display = 'flex';
            }
            async loadLicense() {
                const btn = document.getElementById('licenseBtn');
                const originalText = btn.textContent;
                btn.textContent = this.t('loadingText') + '...';
                btn.disabled = true;
                try {
                    const response = await fetch('LICENSE');
                    if (!response.ok) throw new Error(`File not found (error ${response.status})`);
                    const licenseText = await response.text();
                    this.showLicenseModal(licenseText);
                } catch (error) {
                    console.warn('License loading failed:', error.message);
                    this.showOfflineInstructions(error.message);
                } finally {
                    btn.textContent = originalText;
                    btn.disabled = false;
                }
            }
        }
        const localization = new LocalizationManager();
        
        const INACTIVITY_TIMEOUT_SECONDS = 300;
        const WORLD_SIZE_MAX = 3840;
        const MAX_ATTEMPTS_FOR_PLACEMENT = 100;
        const MIN_DIST_FROM_CENTER = 200;
        const MAX_DIST_FROM_CENTER = 1000;
        const MAX_EXP_TABLE_SIZE = 5500;
        const MAX_ATTEMPTS_FIND_POINT = 100;
        const VERY_COMPLEX_PROXIMITY_FACTOR = 1.5;
        const PROXIMITY_FACTOR_COMPLEXITY = 2;
        const PROXIMITY_FACTOR_COMPLEXITY_MODERATE = 3;
        const MIN_COLLISION_DISTANCE = 1.0;
        const PLACEMENT_MARGIN = 100;
        let expFuncTable = null;
        let expFuncTableCube = null;
        
        class Planet {
            constructor(x, y, radius, color, mass) {
                this.x = x;
                this.y = y;
                this.vx = 0;
                this.vy = 0;
                this.ax = 0;
                this.ay = 0;
                this.axPrev = 0;
                this.ayPrev = 0;
                this.radius = radius;
                this.color = color;
                this.mass = mass;
                this.isLocked = false;
            }
            draw(ctx, scaleX, scaleY, offsetX = 0, offsetY = 0) {
                const screenPos = {
                    x: (this.x + offsetX + GravityGame.worldWidth / 2) * scaleX,
                    y: (this.y + offsetY + GravityGame.worldHeight / 2) * scaleY
                };
                const screenRadius = this.radius * scaleX;
                ctx.beginPath();
                ctx.arc(screenPos.x, screenPos.y, screenRadius, 0, Math.PI * 2);
                ctx.fillStyle = this.color;
                ctx.fill();
            }
            getSpeed() {
                return Math.sqrt(this.vx * this.vx + this.vy * this.vy);
            }
        }
        
        function toroidalDelta(a, b, size) {
            const d = a - b;
            return d - size * Math.round(d / size);
        }
        
        function normalizeCoordinate(coord, size) {
            return ((coord + size / 2) % size) - size / 2;
        }
        
        class GravityGame {
            static worldWidth = WORLD_SIZE_MAX;
            static worldHeight = WORLD_SIZE_MAX;
            
            constructor() {
                this.canvas = document.getElementById('gameCanvas');
                this.ctx = this.canvas.getContext('2d');
                if (!this.ctx) {
                    console.error('Failed to get 2D canvas context');
                    return;
                }
                this.planets = [];
                this.settings = {};
                this.isRunning = false;
                this.isPaused = false;
                this.lastTime = 0;
                this.frameCount = 0;
                this.physicsStepsPerFrame = 60;
                this.inactivityTimer = null;
                this.lastCanvasClickTime = 0;
                this.exitClickDelay = 1000;
                this.boundGameLoop = this.gameLoop.bind(this);
                
                // –ò–ó–ú–ï–ù–ï–ù–ò–ï 1: –£–º–µ–Ω—å—à–∏–ª –∏–Ω—Ç–µ—Ä–≤–∞–ª –ø–æ–≤—Ç–æ—Ä–∞ —Å 150 –º—Å –Ω–∞ 100 –º—Å
                this.touchControlState = {
                    active: false,
                    currentZone: null,
                    repeatTimer: null,
                    initialDelayTimer: null,
                    lastActionTime: 0,
                    repeatInterval: 100, // –ò–∑–º–µ–Ω–µ–Ω–æ —Å 150 –Ω–∞ 100 –º—Å
                    initialDelay: 300,
                    pointerId: null
                };
                
                this.setupVisibilityListener();
                this.setupEventListeners();
                this.resizeCanvas();
                this.initPlanetSettingsUI();
                this.bindUIListeners();
                this.updatePlanetSettingsVisibility();
                this.updateGravityConstant();
                this.updatePlanetCountOptions();
                
                this.setupRealTimeKeyControls();
                this.setupRealTimeTouchControls();
                this.setupCoordinateMode();
            }
            
            setupVisibilityListener() {
                document.addEventListener('visibilitychange', () => {
                    if (document.hidden) {
                        if (this.isRunning) {
                            this.isPaused = true;
                            this.isRunning = false;
                            if (this.inactivityTimer) clearTimeout(this.inactivityTimer);
                            this.stopTouchControl();
                        }
                    } else {
                        if (this.isPaused) {
                            this.isPaused = false;
                            this.isRunning = true;
                            this.lastTime = performance.now();
                            this.startInactivityTimer();
                            requestAnimationFrame(this.boundGameLoop);
                        }
                    }
                });
            }
            
            setupRealTimeKeyControls() {
                document.addEventListener('keydown', (e) => {
                    if (!this.isRunning) return;
                    const activeModal = document.querySelector('.modal-overlay[style*="display: flex"]');
                    if (activeModal) return;
                    
                    switch(e.key) {
                        case 'ArrowUp':
                            e.preventDefault();
                            this.adjustGravityConstant('+');
                            break;
                        case 'ArrowDown':
                            e.preventDefault();
                            this.adjustGravityConstant('-');
                            break;
                        case 'ArrowRight':
                            e.preventDefault();
                            this.adjustCentralMass('+');
                            break;
                        case 'ArrowLeft':
                            e.preventDefault();
                            this.adjustCentralMass('-');
                            break;
                    }
                });
            }
            
            setupRealTimeTouchControls() {
                const ZONE_WIDTH_FRACTION = 1/6;
                
                const getTouchZone = (x, y, width, height) => {
                    const isLandscape = width >= height;
                    const isLeft = x < width * ZONE_WIDTH_FRACTION;
                    const isRight = x > width * (1 - ZONE_WIDTH_FRACTION);
                    const isTop = y < height * ZONE_WIDTH_FRACTION;
                    const isBottom = y > height * (1 - ZONE_WIDTH_FRACTION);
                    
                    if (isLandscape) {
                        if (isLeft) return 'left';
                        if (isRight) return 'right';
                        if (isTop) return 'top';
                        if (isBottom) return 'bottom';
                    } else {
                        if (isTop) return 'top';
                        if (isBottom) return 'bottom';
                        if (isLeft) return 'left';
                        if (isRight) return 'right';
                    }
                    return null;
                };
                
                const isInCentralZone = (x, y, width, height) => {
                    const margin = width * ZONE_WIDTH_FRACTION;
                    return x >= margin && x <= width - margin && y >= margin && y <= height - margin;
                };
                
                const setupDoubleClickForExit = () => {
                    let lastClickTime = 0;
                    let lastClickX = 0;
                    let lastClickY = 0;
                    
                    const handleClick = (clientX, clientY) => {
                        if (!this.isRunning) return;
                        
                        const rect = this.canvas.getBoundingClientRect();
                        const x = clientX - rect.left;
                        const y = clientY - rect.top;
                        
                        if (isInCentralZone(x, y, this.canvas.width, this.canvas.height)) {
                            const currentTime = Date.now();
                            if (currentTime - lastClickTime < 300 &&
                                Math.abs(x - lastClickX) < 10 &&
                                Math.abs(y - lastClickY) < 10) {
                                this.returnToSetup();
                                return;
                            }
                            lastClickTime = currentTime;
                            lastClickX = x;
                            lastClickY = y;
                        }
                    };
                    
                    this.canvas.addEventListener('click', (e) => {
                        handleClick(e.clientX, e.clientY);
                    });
                    
                    this.canvas.addEventListener('touchend', (e) => {
                        if (e.touches.length === 0 && e.changedTouches.length === 1) {
                            const touch = e.changedTouches[0];
                            handleClick(touch.clientX, touch.clientY);
                        }
                    });
                };
                
                // –ò–ó–ú–ï–ù–ï–ù–ò–ï 2: –î–æ–±–∞–≤–∏–ª –∞–≤—Ç–æ–ø–æ–≤—Ç–æ—Ä –¥–ª—è –º—ã—à–∏
                const handlePointerEvent = (e) => {
                    if (!this.isRunning || this.isPaused) return;
                    
                    const activeModal = document.querySelector('.modal-overlay[style*="display: flex"]');
                    if (activeModal) return;
                    
                    const rect = this.canvas.getBoundingClientRect();
                    const x = e.clientX - rect.left;
                    const y = e.clientY - rect.top;
                    
                    const zone = getTouchZone(x, y, this.canvas.width, this.canvas.height);
                    
                    if (zone) {
                        e.preventDefault();
                        
                        if (e.type === 'pointerdown' || e.type === 'mousedown' || e.type === 'touchstart') {
                            this.touchControlState.active = true;
                            this.touchControlState.currentZone = zone;
                            this.touchControlState.pointerId = e.pointerId;
                            
                            this.performTouchAction(zone);
                            this.touchControlState.lastActionTime = Date.now();
                            this.startTouchRepeatTimer(zone); // –î–æ–±–∞–≤–ª—è–µ–º –∑–∞–ø—É—Å–∫ —Ç–∞–π–º–µ—Ä–∞ –¥–ª—è –º—ã—à–∏
                        }
                    }
                    
                    if (e.type === 'pointerup' || e.type === 'mouseup' || 
                        e.type === 'pointercancel' || e.type === 'mouseleave' ||
                        e.type === 'touchend') {
                        this.stopTouchControl();
                    }
                };
                
                setupDoubleClickForExit();
                
                this.canvas.addEventListener('pointerdown', handlePointerEvent);
                this.canvas.addEventListener('pointerup', handlePointerEvent);
                this.canvas.addEventListener('pointercancel', handlePointerEvent);
                this.canvas.addEventListener('mouseleave', handlePointerEvent);
                
                this.canvas.addEventListener('touchstart', (e) => {
                    if (e.touches.length === 1) {
                        const rect = this.canvas.getBoundingClientRect();
                        const touch = e.touches[0];
                        const x = touch.clientX - rect.left;
                        const y = touch.clientY - rect.top;
                        
                        const zone = getTouchZone(x, y, this.canvas.width, this.canvas.height);
                        if (zone) {
                            e.preventDefault();
                            this.touchControlState.active = true;
                            this.touchControlState.currentZone = zone;
                            
                            this.performTouchAction(zone);
                            this.touchControlState.lastActionTime = Date.now();
                            this.startTouchRepeatTimer(zone);
                        }
                    }
                }, { passive: false });
                
                this.canvas.addEventListener('touchend', () => {
                    this.stopTouchControl();
                });
                
                this.canvas.addEventListener('contextmenu', (e) => {
                    e.preventDefault();
                });
            }
            
            performTouchAction(zone) {
                switch(zone) {
                    case 'left': this.adjustCentralMass('-'); break;
                    case 'right': this.adjustCentralMass('+'); break;
                    case 'top': this.adjustGravityConstant('+'); break;
                    case 'bottom': this.adjustGravityConstant('-'); break;
                }
            }
            
            startTouchRepeatTimer(zone) {
                if (this.touchControlState.initialDelayTimer) {
                    clearTimeout(this.touchControlState.initialDelayTimer);
                }
                if (this.touchControlState.repeatTimer) {
                    clearInterval(this.touchControlState.repeatTimer);
                }
                
                this.touchControlState.initialDelayTimer = setTimeout(() => {
                    this.touchControlState.repeatTimer = setInterval(() => {
                        const now = Date.now();
                        if (now - this.touchControlState.lastActionTime >= this.touchControlState.repeatInterval) {
                            this.performTouchAction(zone);
                            this.touchControlState.lastActionTime = now;
                        }
                    }, this.touchControlState.repeatInterval);
                }, this.touchControlState.initialDelay);
            }
            
            stopTouchControl() {
                if (this.touchControlState.initialDelayTimer) {
                    clearTimeout(this.touchControlState.initialDelayTimer);
                    this.touchControlState.initialDelayTimer = null;
                }
                if (this.touchControlState.repeatTimer) {
                    clearInterval(this.touchControlState.repeatTimer);
                    this.touchControlState.repeatTimer = null;
                }
                this.touchControlState.active = false;
                this.touchControlState.currentZone = null;
                this.touchControlState.pointerId = null;
            }
            
            adjustGravityConstant(operation) {
                const input = document.getElementById('gravityConstant');
                if (!input) return;
                
                const step = parseFloat(input.step) || 1;
                const min = parseFloat(input.min) || 1;
                const max = parseFloat(input.max) || 1000;
                
                let newValue = parseFloat(input.value);
                
                if (operation === '+') {
                    newValue += step;
                    if (newValue > max) newValue = max;
                } else {
                    newValue -= step;
                    if (newValue < min) newValue = min;
                }
                
                input.value = newValue;
                this.settings.gravityConstant = newValue;
            }
            
            adjustCentralMass(operation) {
                const input = document.getElementById('centralMass');
                if (!input) return;
                
                const step = parseFloat(input.step) || 10000;
                const min = parseFloat(input.min) || 0;
                const max = parseFloat(input.max) || 10000000;
                
                let newValue = parseFloat(input.value);
                
                if (operation === '+') {
                    newValue += step;
                    if (newValue > max) newValue = max;
                } else {
                    newValue -= step;
                    if (newValue < min) newValue = min;
                }
                
                input.value = newValue;
                this.settings.centralMass = newValue;
            }
            
            worldToScreen(worldX, worldY) {
                const scaleX = this.canvas.width / GravityGame.worldWidth;
                const scaleY = this.canvas.height / GravityGame.worldHeight;
                return {
                    x: (worldX + GravityGame.worldWidth / 2) * scaleX,
                    y: (worldY + GravityGame.worldHeight / 2) * scaleY
                };
            }
            
            screenToWorld(screenX, screenY) {
                const scaleX = this.canvas.width / GravityGame.worldWidth;
                const scaleY = this.canvas.height / GravityGame.worldHeight;
                return {
                    x: screenX / scaleX - GravityGame.worldWidth / 2,
                    y: screenY / scaleY - GravityGame.worldHeight / 2
                };
            }
            
            bindUIListeners() {
                const gravityFunctionTypeSelect = document.getElementById('gravityFunctionType');
                gravityFunctionTypeSelect.addEventListener('change', () => {
                    this.updateGravityConstant();
                    this.updatePlanetCountOptions();
                });
                document.getElementById('usePrecomputedTable').addEventListener('change', (e) => {
                    this.updatePlanetCountOptions();
                    if (!e.target.checked) {
                        const gravityFunctionType = document.getElementById('gravityFunctionType').value;
                        if (gravityFunctionType === '1' || gravityFunctionType === '5') {
                            const planetCountSelect = document.getElementById('planetCount');
                            const currentValue = parseInt(planetCountSelect.value);
                            if (currentValue > 7) {
                                planetCountSelect.value = '7';
                                this.updatePlanetSettingsVisibility();
                            }
                        }
                    }
                });
                const planetCountSelect = document.getElementById('planetCount');
                planetCountSelect.addEventListener('change', () => {
                    this.updatePlanetSettingsVisibility();
                });
                document.getElementById('planetSettingsButton').addEventListener('click', () => {
                    this.showScreen('SettingsScreen');
                });
                document.getElementById('openPlanetEdit').addEventListener('click', () => {
                    this.showScreen('IndividualPlanetSettingsScreen');
                });
                document.getElementById('backFromSettings').addEventListener('click', () => {
                    settingsManager.save(settingsManager.getCurrentUISettings());
                    game.showScreen('setupScreen');
                });
                document.getElementById('backFromIndividualPlanet').addEventListener('click', () => {
                    this.showScreen('SettingsScreen');
                });
                
                // –û–±—Ä–∞–±–æ—Ç—á–∏–∫–∏ –¥–ª—è —Ä–µ–∂–∏–º–∞ –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç
                document.getElementById('coordConfirmBtn').addEventListener('click', () => this.handleCoordinateConfirm());
                document.getElementById('coordResetBtn').addEventListener('click', () => this.resetCoordinateInputs());
                document.getElementById('coordCancelBtn').addEventListener('click', () => this.cancelCoordinateInput());
                
                // –ê–≤—Ç–æ–ø–µ—Ä–µ—Ö–æ–¥ –º–µ–∂–¥—É –ø–æ–ª—è–º–∏ –≤–≤–æ–¥–∞
                const coordInputs = document.querySelectorAll('.coord-input');
                coordInputs.forEach(input => {
                    input.addEventListener('input', (e) => {
                        if (e.target.value.length >= 4 || (e.target.value.includes('-') && e.target.value.length >= 5)) {
                            const nextIndex = parseInt(e.target.dataset.index) + 1;
                            const nextInput = document.querySelector(`.coord-input[data-index="${nextIndex}"]`);
                            if (nextInput) {
                                setTimeout(() => {
                                    nextInput.focus();
                                    nextInput.select();
                                }, 50);
                            }
                        }
                    });
                    
                    input.addEventListener('keydown', (e) => {
                        if (e.key === 'Enter' || e.key === 'Tab') {
                            e.preventDefault();
                            const nextIndex = parseInt(e.target.dataset.index) + 1;
                            const nextInput = document.querySelector(`.coord-input[data-index="${nextIndex}"]`);
                            if (nextInput) {
                                nextInput.focus();
                                nextInput.select();
                            } else {
                                document.getElementById('coordConfirmBtn')?.focus();
                            }
                        } else if (e.key === 'Escape') {
                            this.resetCoordinateInputs();
                        }
                    });
                    
                    input.addEventListener('blur', () => {
                        this.validateCoordinateInput(input, parseInt(input.dataset.index));
                    });
                });
            }
            
            updatePlanetCountOptions() {
                const gravityFunctionType = document.getElementById('gravityFunctionType').value;
                const usePrecomputedTable = document.getElementById('usePrecomputedTable').checked;
                const planetCountSelect = document.getElementById('planetCount');
                const maxPlanets = ((gravityFunctionType === '1' || gravityFunctionType === '5') && !usePrecomputedTable) ? 7 : 9;
                const current = parseInt(planetCountSelect.value);
                let newValue = current <= maxPlanets ? current : maxPlanets;
                planetCountSelect.innerHTML = '';
                for (let i = 2; i <= 9; i++) {
                    if (i <= maxPlanets) {
                        const opt = document.createElement('option');
                        opt.value = i;
                        opt.textContent = i;
                        planetCountSelect.appendChild(opt);
                    }
                }
                planetCountSelect.value = newValue;
            }
            
            showScreen(screenId) {
                ['setupScreen', 'SettingsScreen', 'IndividualPlanetSettingsScreen'].forEach(id => {
                    document.getElementById(id).style.display = (id === screenId) ? 'flex' : 'none';
                });
            }
            
            initPlanetSettingsUI() {
                const container = document.getElementById('planetSettingsContainer');
                container.innerHTML = '';
                for (let i = 1; i <= 9; i++) {
                    const div = document.createElement('div');
                    div.className = 'planet-setting';
                    div.id = `planetSetting${i}`;
                    div.innerHTML = `
                        <div class="planet-color-preview" id="preview${i}"></div>
                        <input type="number" id="mass${i}" min="1000" max="100000" step="1000" value="10000" placeholder="Mass">
                        <select id="color${i}">
                            ${DEFAULT_COLORS.map(c => `<option value="${c}">${c}</option>`).join('')}
                        </select>
                    `;
                    container.appendChild(div);
                    const colorSelect = document.getElementById(`color${i}`);
                    const preview = document.getElementById(`preview${i}`);
                    colorSelect.value = DEFAULT_COLORS[i - 1];
                    preview.style.background = DEFAULT_COLORS[i - 1];
                    colorSelect.addEventListener('change', () => {
                        preview.style.background = colorSelect.value;
                    });
                }
            }
            
            updatePlanetSettingsVisibility() {
                const planetCount = parseInt(document.getElementById('planetCount').value);
                for (let i = 1; i <= 9; i++) {
                    const field = document.getElementById(`planetSetting${i}`);
                    if (field) {
                        field.style.display = i <= planetCount ? 'flex' : 'none';
                    }
                }
            }
            
            updateGravityConstant() {
                const functionType = document.getElementById('gravityFunctionType').value;
                const gravityInput = document.getElementById('gravityConstant');
                let value, min, max, step;
                switch (functionType) {
                    case '1': min = 0.01; max = 10; step = 0.01; value = 0.5; break;
                    case '2': min = 1; max = 1000; step = 1; value = 200; break; // –ò–ó–ú–ï–ù–ï–ù–û: 1-1000, —à–∞–≥ 1
                    case '3': min = 0.01; max = 10; step = 0.01; value = 0.5; break;
                    case '4': min = 0.1; max = 100; step = 0.1; value = 10; break;
                    case '5': min = 0.1; max = 100; step = 0.1; value = 10; break;
                }
                gravityInput.min = min.toString();
                gravityInput.max = max.toString();
                gravityInput.step = step.toString();
                gravityInput.value = Math.max(min, Math.min(max, value)).toString();
            }
            
            setupEventListeners() {
                window.addEventListener('resize', () => this.resizeCanvas());
                const resetInactivityTimer = () => {
                    if (this.isRunning) {
                        this.startInactivityTimer();
                    }
                };
                document.addEventListener('touchstart', resetInactivityTimer);
                document.addEventListener('keydown', (e) => {
                    if (e.key === 'Escape') {
                        if (this.isRunning) {
                            this.returnToSetup();
                        } else {
                            this.showScreen('setupScreen');
                        }
                    } else {
                        resetInactivityTimer();
                    }
                });
                this.canvas.addEventListener('click', (e) => {
                    e.stopPropagation();
                    const currentTime = performance.now();
                    if (currentTime - this.lastCanvasClickTime < this.exitClickDelay) {
                        this.returnToSetup();
                    } else {
                        this.lastCanvasClickTime = currentTime;
                        this.showExitHint();
                    }
                });
                let lastTouchEnd = 0;
                this.canvas.addEventListener('touchend', (e) => {
                    e.preventDefault();
                    const currentTime = performance.now();
                    if (currentTime - lastTouchEnd < this.exitClickDelay) {
                        this.returnToSetup();
                    }
                    lastTouchEnd = currentTime;
                });
            }
            
            showExitHint() {
                const hint = document.createElement('div');
                hint.textContent = localization.t('doubleClickHint');
                hint.style.cssText = `
                    position: fixed; top: 20px; left: 50%; transform: translateX(-50%);
                    background: rgba(255,170,0,0.9); color: #000; padding: 8px 16px;
                    border-radius: 5px; font-size: 14px; z-index: 50;
                    pointer-events: none; transition: opacity 0.5s;
                `;
                document.body.appendChild(hint);
                setTimeout(() => {
                    hint.style.opacity = '0';
                    setTimeout(() => hint.remove(), 500);
                }, 800);
            }
            
            resizeCanvas() {
                this.canvas.width = window.innerWidth;
                this.canvas.height = window.innerHeight;
                const aspect = this.canvas.width / this.canvas.height;
                if (this.canvas.width >= this.canvas.height) {
                    GravityGame.worldWidth = WORLD_SIZE_MAX;
                    GravityGame.worldHeight = WORLD_SIZE_MAX / aspect;
                } else {
                    GravityGame.worldHeight = WORLD_SIZE_MAX;
                    GravityGame.worldWidth = WORLD_SIZE_MAX * aspect;
                }
            }
            
            generateRandomPositions() {
                const minDistFromCenter = MIN_DIST_FROM_CENTER;
                const maxDistFromCenter = MAX_DIST_FROM_CENTER;
                const maxAttempts = MAX_ATTEMPTS_FOR_PLACEMENT;
                for (let i = 0; i < this.settings.planetCount; i++) {
                    let x, y;
                    let attempts = 0;
                    let validPosition = false;
                    while (!validPosition && attempts < maxAttempts) {
                        const minX = -GravityGame.worldWidth / 2 + PLACEMENT_MARGIN;
                        const maxX = GravityGame.worldWidth / 2 - PLACEMENT_MARGIN;
                        const minY = -GravityGame.worldHeight / 2 + PLACEMENT_MARGIN;
                        const maxY = GravityGame.worldHeight / 2 - PLACEMENT_MARGIN;
                        x = Math.random() * (maxX - minX) + minX;
                        y = Math.random() * (maxY - minY) + minY;
                        const distFromCenter = Math.sqrt(x * x + y * y);
                        if (distFromCenter < minDistFromCenter || distFromCenter > maxDistFromCenter) {
                            attempts++;
                            continue;
                        }
                        let tooClose = false;
                        for (const p of this.planets) {
                            const dx = x - p.x;
                            const dy = y - p.y;
                            const dist = Math.sqrt(dx * dx + dy * dy);
                            if (dist < this.settings.planetRadius * 2 + 20) {
                                tooClose = true;
                                break;
                            }
                        }
                        if (!tooClose) {
                            validPosition = true;
                        } else {
                            attempts++;
                        }
                    }
                    if (!validPosition) {
                        const angle = (2 * Math.PI * i) / this.settings.planetCount;
                        x = MIN_DIST_FROM_CENTER * Math.cos(angle);
                        y = MIN_DIST_FROM_CENTER * Math.sin(angle);
                    }
                    this.planets.push(new Planet(x, y, this.settings.planetRadius, this.settings.planetColors[i], this.settings.planetMasses[i]));
                }
                this.isRunning = true;
                this.lastTime = performance.now();
                this.startInactivityTimer();
                requestAnimationFrame(this.boundGameLoop);
            }
            
            setupCoordinateMode() {
                // –ù–∞—Å—Ç—Ä–æ–π–∫–∞ –º–∏–Ω–∏–º–∞–ª—å–Ω—ã—Ö –∏ –º–∞–∫—Å–∏–º–∞–ª—å–Ω—ã—Ö –∑–Ω–∞—á–µ–Ω–∏–π –¥–ª—è –ø–æ–ª–µ–π –≤–≤–æ–¥–∞
                const maxX = Math.floor(GravityGame.worldWidth / 2);
                const maxY = Math.floor(GravityGame.worldHeight / 2);
                const coordInputs = document.querySelectorAll('.coord-input');
                coordInputs.forEach((input, index) => {
                    if (index === 0 || index === 2) { // X –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã
                        input.min = -maxX;
                        input.max = maxX;
                    } else { // Y –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã
                        input.min = -maxY;
                        input.max = maxY;
                    }
                });
            }
            
            generateManualPositions() {
                this.manualModeData = {
                    isActive: true,
                    currentPlanetIndex: 0,
                    mode: parseInt(this.settings.startMode) === 4 ? 'coords' : 'drag',
                    startPos: null,
                    isDragging: false,
                    keyboardMode: false,
                    cursorPos: {x: 0, y: 0},
                    velocityEndPos: null
                };
                
                this.manualArrows = [];
                this.planets = [];
                
                if (this.manualModeData.mode === 'coords') {
                    this.showCoordinateInputUI();
                } else {
                    this.showManualModeUI();
                    this.setupPointerEventsForManualMode();
                    this.setupKeyboardManualMode();
                }
                
                this.render();
            }
            
            setupPointerEventsForManualMode() {
                const handlePointerEvent = (e) => {
                    if (!this.manualModeData || !this.manualModeData.isActive || this.manualModeData.mode !== 'drag') return;
                    
                    const rect = this.canvas.getBoundingClientRect();
                    let clientX, clientY;
                    
                    if (e.type.includes('pointer') || e.type.includes('mouse')) {
                        clientX = e.clientX;
                        clientY = e.clientY;
                    } else if (e.touches && e.touches[0]) {
                        clientX = e.touches[0].clientX;
                        clientY = e.touches[0].clientY;
                    } else if (e.type === 'keydown') {
                        return;
                    }
                    
                    const worldPos = this.screenToWorld(clientX - rect.left, clientY - rect.top);
                    
                    switch(e.type) {
                        case 'pointerdown':
                        case 'mousedown':
                        case 'touchstart':
                            if (this.manualModeData.isDragging) return;
                            if (!this.isValidPlanetPosition(worldPos)) {
                                this.showManualError();
                                return;
                            }
                            this.manualModeData.startPos = worldPos;
                            this.manualModeData.isDragging = true;
                            if (e.pointerId) this.canvas.setPointerCapture(e.pointerId);
                            this.redrawScene();
                            break;
                        case 'pointermove':
                        case 'mousemove':
                        case 'touchmove':
                            if (!this.manualModeData.isDragging) return;
                            this.drawVectorPreview(this.manualModeData.startPos, worldPos);
                            break;
                        case 'pointerup':
                        case 'mouseup':
                        case 'touchend':
                            if (!this.manualModeData.isDragging) return;
                            const dx = worldPos.x - this.manualModeData.startPos.x;
                            const dy = worldPos.y - this.manualModeData.startPos.y;
                            const planet = new Planet(
                                this.manualModeData.startPos.x,
                                this.manualModeData.startPos.y,
                                this.settings.planetRadius,
                                this.settings.planetColors[this.manualModeData.currentPlanetIndex],
                                this.settings.planetMasses[this.manualModeData.currentPlanetIndex]
                            );
                            planet.vx = dx / 4;
                            planet.vy = dy / 4;
                            this.planets.push(planet);
                            this.manualArrows.push({
                                start: {x: this.manualModeData.startPos.x, y: this.manualModeData.startPos.y},
                                end: {x: worldPos.x, y: worldPos.y},
                                color: this.settings.planetColors[this.manualModeData.currentPlanetIndex]
                            });
                            this.redrawScene();
                            this.manualModeData.currentPlanetIndex++;
                            this.manualModeData.isDragging = false;
                            if (e.pointerId) this.canvas.releasePointerCapture(e.pointerId);
                            if (this.manualModeData.currentPlanetIndex >= this.settings.planetCount) {
                                this.finishManualMode();
                            } else {
                                this.showManualModeUI();
                            }
                            break;
                    }
                };
                
                this.canvas.addEventListener('pointerdown', handlePointerEvent);
                this.canvas.addEventListener('pointermove', handlePointerEvent);
                this.canvas.addEventListener('pointerup', handlePointerEvent);
                
                this.canvas.addEventListener('touchstart', handlePointerEvent, { passive: false });
                this.canvas.addEventListener('touchmove', handlePointerEvent, { passive: false });
                this.canvas.addEventListener('touchend', handlePointerEvent);
            }
            
            setupKeyboardManualMode() {
                document.addEventListener('keydown', (e) => {
                    if (!this.manualModeData || !this.manualModeData.isActive || this.manualModeData.mode !== 'drag') return;
                    
                    if (e.key === 'Escape') {
                        e.preventDefault();
                        if (this.manualModeData.startPos !== null) {
                            this.manualModeData.startPos = null;
                            this.manualModeData.velocityEndPos = null;
                            this.manualModeData.cursorPos = {x: 0, y: 0};
                            this.redrawScene();
                        } else if (this.planets.length > 0) {
                            this.planets.pop();
                            this.manualArrows.pop();
                            this.manualModeData.currentPlanetIndex--;
                            this.showManualModeUI();
                            this.redrawScene();
                        }
                        return;
                    }
                    
                    if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'].includes(e.key)) {
                        this.manualModeData.keyboardMode = true;
                        e.preventDefault();
                        this.handleKeyboardInManualMode(e);
                    }
                    else if (e.key === ' ' || e.key === 'Enter') {
                        e.preventDefault();
                        this.handleKeyboardConfirm();
                    }
                });
                
                this.canvas.addEventListener('mousemove', () => {
                    if (this.manualModeData && this.manualModeData.isActive) {
                        this.manualModeData.keyboardMode = false;
                    }
                });
                this.canvas.addEventListener('touchstart', () => {
                    if (this.manualModeData && this.manualModeData.isActive) {
                        this.manualModeData.keyboardMode = false;
                    }
                });
            }
            
            handleKeyboardInManualMode(e) {
                if (!this.manualModeData.keyboardMode) return;
                
                const moveStep = 4;
                let dx = 0, dy = 0;
                
                switch(e.key) {
                    case 'ArrowUp': dy = -moveStep; break;
                    case 'ArrowDown': dy = moveStep; break;
                    case 'ArrowLeft': dx = -moveStep; break;
                    case 'ArrowRight': dx = moveStep; break;
                }
                
                const screenStepX = dx * (GravityGame.worldWidth / this.canvas.width);
                const screenStepY = dy * (GravityGame.worldHeight / this.canvas.height);
                
                if (this.manualModeData.startPos === null) {
                    this.manualModeData.cursorPos.x += screenStepX;
                    this.manualModeData.cursorPos.y += screenStepY;
                    
                    const halfW = GravityGame.worldWidth / 2 - PLACEMENT_MARGIN;
                    const halfH = GravityGame.worldHeight / 2 - PLACEMENT_MARGIN;
                    this.manualModeData.cursorPos.x = Math.max(-halfW, Math.min(halfW, this.manualModeData.cursorPos.x));
                    this.manualModeData.cursorPos.y = Math.max(-halfH, Math.min(halfH, this.manualModeData.cursorPos.y));
                } else {
                    if (this.manualModeData.velocityEndPos === null) {
                        this.manualModeData.velocityEndPos = {
                            x: this.manualModeData.startPos.x + screenStepX,
                            y: this.manualModeData.startPos.y + screenStepY
                        };
                    } else {
                        this.manualModeData.velocityEndPos.x += screenStepX;
                        this.manualModeData.velocityEndPos.y += screenStepY;
                    }
                }
                
                this.redrawScene();
            }
            
            handleKeyboardConfirm() {
                if (!this.manualModeData.keyboardMode) return;
                
                if (this.manualModeData.startPos === null) {
                    if (!this.isValidPlanetPosition(this.manualModeData.cursorPos)) {
                        this.showManualError();
                        return;
                    }
                    
                    this.manualModeData.startPos = {
                        x: this.manualModeData.cursorPos.x,
                        y: this.manualModeData.cursorPos.y
                    };
                    this.manualModeData.velocityEndPos = {
                        x: this.manualModeData.cursorPos.x,
                        y: this.manualModeData.cursorPos.y
                    };
                } else {
                    const endPos = this.manualModeData.velocityEndPos || this.manualModeData.startPos;
                    const dx = endPos.x - this.manualModeData.startPos.x;
                    const dy = endPos.y - this.manualModeData.startPos.y;
                    
                    const planet = new Planet(
                        this.manualModeData.startPos.x,
                        this.manualModeData.startPos.y,
                        this.settings.planetRadius,
                        this.settings.planetColors[this.manualModeData.currentPlanetIndex],
                        this.settings.planetMasses[this.manualModeData.currentPlanetIndex]
                    );
                    planet.vx = dx / 4;
                    planet.vy = dy / 4;
                    this.planets.push(planet);
                    
                    this.manualArrows.push({
                        start: {x: this.manualModeData.startPos.x, y: this.manualModeData.startPos.y},
                        end: {x: endPos.x, y: endPos.y},
                        color: this.settings.planetColors[this.manualModeData.currentPlanetIndex]
                    });
                    
                    this.manualModeData.currentPlanetIndex++;
                    this.manualModeData.startPos = null;
                    this.manualModeData.cursorPos = {x: 0, y: 0};
                    this.manualModeData.velocityEndPos = null;
                    
                    if (this.manualModeData.currentPlanetIndex >= this.settings.planetCount) {
                        this.finishManualMode();
                    } else {
                        this.showManualModeUI();
                    }
                }
                
                this.redrawScene();
            }
            
            validateCoordinateInput(input, index) {
                const value = parseFloat(input.value);
                const maxX = Math.floor(GravityGame.worldWidth / 2);
                const maxY = Math.floor(GravityGame.worldHeight / 2);
                
                let min, max;
                if (index === 0 || index === 2) {
                    min = -maxX;
                    max = maxX;
                } else {
                    min = -maxY;
                    max = maxY;
                }
                
                if (input.value === '' || isNaN(value)) {
                    input.style.background = '';
                    input.style.borderColor = '#666';
                    input.title = localization.t('coordEnterNumber');
                    return false;
                } else if (value < min || value > max) {
                    input.style.background = 'rgba(255, 0, 0, 0.15)';
                    input.style.borderColor = '#ff4444';
                    input.title = localization.t('coordValidationError', min, max);
                    return false;
                } else {
                    input.style.background = 'rgba(0, 255, 0, 0.08)';
                    input.style.borderColor = '#4CAF50';
                    input.title = localization.t('coordValidValue');
                    return true;
                }
            }
            
            showCoordinateInputUI() {
                const indicator = document.getElementById('manualModeIndicator');
                indicator.textContent = localization.t('manualModeCoordinatePlace', 
                    this.manualModeData.currentPlanetIndex + 1, this.settings.planetCount
                );
                indicator.style.display = 'block';
                indicator.style.background = 'rgba(255, 165, 0, 0.9)';
                
                document.getElementById('coordInputContainer').style.display = 'flex';
                
                const title = document.getElementById('coordInputTitle');
                title.textContent = `–í–≤–æ–¥ –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç: –ü–ª–∞–Ω–µ—Ç–∞ ${this.manualModeData.currentPlanetIndex + 1} –∏–∑ ${this.settings.planetCount}`;
                
                const maxX = Math.floor(GravityGame.worldWidth / 2);
                const maxY = Math.floor(GravityGame.worldHeight / 2);
                const minDist = this.settings.planetRadius * 2 + 20;
                const rangeHint = document.getElementById('coordRangeHint');
                if (rangeHint) {
                    rangeHint.innerHTML = `
                        <strong>${localization.t('coordRangeHint', maxX, maxY)}</strong><br>
                        ${localization.t('coordMinDistance', minDist)}<br>
                        ${localization.t('coordCurrentRadius', this.settings.planetRadius)}
                    `;
                }
                
                this.resetCoordinateInputs();
                
                if (document.getElementById('coordStartX')) {
                    setTimeout(() => {
                        document.getElementById('coordStartX').focus();
                        document.getElementById('coordStartX').select();
                    }, 100);
                }
            }
            
            resetCoordinateInputs() {
                const coordInputs = document.querySelectorAll('.coord-input');
                coordInputs.forEach((input, index) => {
                    input.value = '';
                    input.style.background = '';
                    input.style.borderColor = '#666';
                    input.title = index < 2 ? localization.t('coordStartXHint', Math.floor(GravityGame.worldWidth/2)) : 
                                           localization.t('coordEndXHint', Math.floor(GravityGame.worldWidth/2));
                });
                
                if (document.getElementById('coordStartX')) {
                    setTimeout(() => {
                        document.getElementById('coordStartX').focus();
                        document.getElementById('coordStartX').select();
                    }, 50);
                }
            }
            
            handleCoordinateConfirm() {
                let allValid = true;
                const coordInputs = document.querySelectorAll('.coord-input');
                coordInputs.forEach((input, index) => {
                    if (!this.validateCoordinateInput(input, index)) {
                        allValid = false;
                        input.style.borderColor = '#ff4444';
                        input.style.boxShadow = '0 0 5px rgba(255, 68, 68, 0.5)';
                    }
                });
                
                if (!allValid) {
                    this.showCoordinateError(localization.t('coordFixFields'));
                    return;
                }
                
                const startX = parseFloat(document.getElementById('coordStartX').value) || 0;
                const startY = parseFloat(document.getElementById('coordStartY').value) || 0;
                const endX = parseFloat(document.getElementById('coordEndX').value) || 0;
                const endY = parseFloat(document.getElementById('coordEndY').value) || 0;
                
                const startPos = {x: startX, y: startY};
                if (!this.isValidPlanetPosition(startPos)) {
                    this.showManualError();
                    document.getElementById('coordStartX').style.borderColor = '#ff4444';
                    document.getElementById('coordStartY').style.borderColor = '#ff4444';
                    return;
                }
                
                const planet = new Planet(
                    startX,
                    startY,
                    this.settings.planetRadius,
                    this.settings.planetColors[this.manualModeData.currentPlanetIndex],
                    this.settings.planetMasses[this.manualModeData.currentPlanetIndex]
                );
                
                planet.vx = (endX - startX) / 4;
                planet.vy = (endY - startY) / 4;
                
                this.planets.push(planet);
                
                this.manualArrows.push({
                    start: {x: startX, y: startY},
                    end: {x: endX, y: endY},
                    color: this.settings.planetColors[this.manualModeData.currentPlanetIndex]
                });
                
                this.manualModeData.currentPlanetIndex++;
                
                if (this.manualModeData.currentPlanetIndex >= this.settings.planetCount) {
                    this.finishManualMode();
                } else {
                    this.showCoordinateInputUI();
                    this.redrawScene();
                }
            }
            
            showCoordinateError(message) {
                const errorMsg = document.createElement('div');
                errorMsg.style.cssText = `
                    position: fixed;
                    top: 50%;
                    left: 50%;
                    transform: translate(-50%, -50%);
                    background: rgba(255, 0, 0, 0.9);
                    color: white;
                    padding: 12px 24px;
                    border-radius: 6px;
                    z-index: 1002;
                    font-weight: bold;
                    text-align: center;
                    max-width: 80%;
                    box-shadow: 0 0 15px rgba(255,0,0,0.5);
                    font-size: 14px;
                `;
                errorMsg.textContent = message;
                
                document.body.appendChild(errorMsg);
                
                setTimeout(() => {
                    errorMsg.style.opacity = '0';
                    errorMsg.style.transition = 'opacity 0.5s';
                    setTimeout(() => errorMsg.remove(), 500);
                }, 2000);
            }
            
            cancelCoordinateInput() {
                document.getElementById('coordInputContainer').style.display = 'none';
                const indicator = document.getElementById('manualModeIndicator');
                indicator.style.display = 'none';
                this.returnToSetup();
            }
            
            hideCoordinateInputUI() {
                document.getElementById('coordInputContainer').style.display = 'none';
                const indicator = document.getElementById('manualModeIndicator');
                indicator.style.display = 'none';
            }
            
            isValidPlanetPosition(pos) {
                const minDist = this.settings.planetRadius * 2 + 20;
                for (const p of this.planets) {
                    const dx = toroidalDelta(pos.x, p.x, GravityGame.worldWidth);
                    const dy = toroidalDelta(pos.y, p.y, GravityGame.worldHeight);
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    if (dist < minDist) {
                        return false;
                    }
                }
                return true;
            }
            
            showManualModeUI() {
                const indicator = document.getElementById('manualModeIndicator');
                
                if (this.manualModeData.mode === 'coords') {
                    indicator.textContent = localization.t('manualModeCoordinatePlace', 
                        this.manualModeData.currentPlanetIndex + 1, this.settings.planetCount
                    );
                    indicator.style.background = 'rgba(255, 165, 0, 0.9)';
                } else {
                    indicator.textContent = localization.t('manualModePlacePlanet', 
                        this.manualModeData.currentPlanetIndex + 1, this.settings.planetCount
                    );
                    indicator.style.background = 'rgba(0, 255, 0, 0.9)';
                }
                
                indicator.style.display = 'block';
                
                if (this.manualModeIndicatorTimer) {
                    clearTimeout(this.manualModeIndicatorTimer);
                }
                this.manualModeIndicatorTimer = setTimeout(() => {
                    indicator.style.display = 'none';
                }, 2000);
            }
            
            hideManualModeUI() {
                const indicator = document.getElementById('manualModeIndicator');
                indicator.style.display = 'none';
                if (this.manualModeIndicatorTimer) {
                    clearTimeout(this.manualModeIndicatorTimer);
                    this.manualModeIndicatorTimer = null;
                }
            }
            
            showManualError() {
                const indicator = document.getElementById('manualModeIndicator');
                indicator.textContent = localization.t('manualModeInvalidPosition');
                indicator.style.background = 'rgba(255, 0, 0, 0.9)';
                setTimeout(() => {
                    this.showManualModeUI();
                }, 800);
            }
            
            drawVector(start, end, color) {
                const s = this.worldToScreen(start.x, start.y);
                const e = this.worldToScreen(end.x, end.y);
                this.ctx.save();
                this.ctx.strokeStyle = color + '99';
                this.ctx.lineWidth = 2;
                this.ctx.setLineDash([]);
                this.ctx.beginPath();
                this.ctx.moveTo(s.x, s.y);
                this.ctx.lineTo(e.x, e.y);
                this.ctx.stroke();
                const angle = Math.atan2(e.y - s.y, e.x - s.x);
                this.ctx.beginPath();
                this.ctx.moveTo(e.x, e.y);
                this.ctx.lineTo(e.x - 10 * Math.cos(angle - 0.5), e.y - 10 * Math.sin(angle - 0.5));
                this.ctx.moveTo(e.x, e.y);
                this.ctx.lineTo(e.x - 10 * Math.cos(angle + 0.5), e.y - 10 * Math.sin(angle + 0.5));
                this.ctx.stroke();
                this.ctx.restore();
            }
            
            drawVectorPreview(start, end) {
                this.render();
                this.ctx.save();
                this.ctx.strokeStyle = 'rgba(0, 255, 0, 0.6)';
                this.ctx.lineWidth = 2;
                this.ctx.setLineDash([4, 4]);
                const scaleX = this.canvas.width / GravityGame.worldWidth;
                const scaleY = this.canvas.height / GravityGame.worldHeight;
                const s = this.worldToScreen(start.x, start.y);
                const e = this.worldToScreen(end.x, end.y);
                this.ctx.beginPath();
                this.ctx.moveTo(s.x, s.y);
                this.ctx.lineTo(e.x, e.y);
                this.ctx.stroke();
                const angle = Math.atan2(e.y - s.y, e.x - s.x);
                this.ctx.beginPath();
                this.ctx.moveTo(e.x, e.y);
                this.ctx.lineTo(e.x - 10 * Math.cos(angle - 0.5), e.y - 10 * Math.sin(angle - 0.5));
                this.ctx.moveTo(e.x, e.y);
                this.ctx.lineTo(e.x - 10 * Math.cos(angle + 0.5), e.y - 10 * Math.sin(angle + 0.5));
                this.ctx.stroke();
                this.ctx.fillStyle = this.isValidPlanetPosition(start) 
                    ? 'rgba(255, 255, 255, 0.3)' 
                    : 'rgba(255, 0, 0, 0.3)';
                this.ctx.beginPath();
                this.ctx.arc(s.x, s.y, this.settings.planetRadius * scaleX, 0, Math.PI * 2);
                this.ctx.fill();
                this.ctx.restore();
            }
            
            redrawScene() {
                this.render();
                
                if (this.manualModeData && this.manualModeData.isActive && this.manualModeData.keyboardMode && this.manualModeData.mode === 'drag') {
                    this.ctx.save();
                    
                    if (this.manualModeData.startPos === null) {
                        const cursorScreen = this.worldToScreen(this.manualModeData.cursorPos.x, this.manualModeData.cursorPos.y);
                        this.ctx.fillStyle = this.isValidPlanetPosition(this.manualModeData.cursorPos) 
                            ? 'rgba(0, 0, 255, 0.8)' 
                            : 'rgba(255, 0, 0, 0.8)';
                        this.ctx.beginPath();
                        this.ctx.arc(cursorScreen.x, cursorScreen.y, 8, 0, Math.PI * 2);
                        this.ctx.fill();
                    } else {
                        const startScreen = this.worldToScreen(this.manualModeData.startPos.x, this.manualModeData.startPos.y);
                        
                        this.ctx.fillStyle = 'rgba(0, 0, 255, 0.8)';
                        this.ctx.beginPath();
                        this.ctx.arc(startScreen.x, startScreen.y, 8, 0, Math.PI * 2);
                        this.ctx.fill();
                        
                        if (this.manualModeData.velocityEndPos) {
                            const endScreen = this.worldToScreen(this.manualModeData.velocityEndPos.x, this.manualModeData.velocityEndPos.y);
                            
                            this.ctx.fillStyle = 'rgba(255, 0, 0, 0.8)';
                            this.ctx.beginPath();
                            this.ctx.arc(endScreen.x, endScreen.y, 6, 0, Math.PI * 2);
                            this.ctx.fill();
                            
                            this.ctx.strokeStyle = 'rgba(0, 255, 0, 0.6)';
                            this.ctx.lineWidth = 2;
                            this.ctx.setLineDash([4, 4]);
                            this.ctx.beginPath();
                            this.ctx.moveTo(startScreen.x, startScreen.y);
                            this.ctx.lineTo(endScreen.x, endScreen.y);
                            this.ctx.stroke();
                            
                            const angle = Math.atan2(endScreen.y - startScreen.y, endScreen.x - startScreen.x);
                            this.ctx.beginPath();
                            this.ctx.moveTo(endScreen.x, endScreen.y);
                            this.ctx.lineTo(endScreen.x - 10 * Math.cos(angle - 0.5), endScreen.y - 10 * Math.sin(angle - 0.5));
                            this.ctx.moveTo(endScreen.x, endScreen.y);
                            this.ctx.lineTo(endScreen.x - 10 * Math.cos(angle + 0.5), endScreen.y - 10 * Math.sin(angle + 0.5));
                            this.ctx.stroke();
                        }
                    }
                    
                    this.ctx.restore();
                }
            }
            
            finishManualMode() {
                if (this.manualModeData.mode === 'coords') {
                    this.hideCoordinateInputUI();
                } else {
                    this.hideManualModeUI();
                }
                
                this.manualModeData.isActive = false;
                this.manualArrows = [];
                this.isRunning = true;
                this.lastTime = performance.now();
                this.startInactivityTimer();
                this.render();
                requestAnimationFrame(this.boundGameLoop);
            }
            
            startGame() {
                document.getElementById('error').textContent = '';
                const usePrecomputedTable = document.getElementById('usePrecomputedTable').checked;
                const gravityFunctionType = document.getElementById('gravityFunctionType').value;
                const planetCount = parseInt(document.getElementById('planetCount').value);
                const startMode = parseInt(document.getElementById('startMode').value);
                
                expFuncTable = null;
                expFuncTableCube = null;
                
                if (usePrecomputedTable) {
                    if (gravityFunctionType === '1') {
                        expFuncTable = new Array(MAX_EXP_TABLE_SIZE);
                        for (let r = 0; r < MAX_EXP_TABLE_SIZE; r++) {
                            expFuncTable[r] = Math.exp(0.25 * Math.sqrt(r));
                        }
                    } else if (gravityFunctionType === '5') {
                        expFuncTableCube = new Array(MAX_EXP_TABLE_SIZE);
                        for (let r = 0; r < MAX_EXP_TABLE_SIZE; r++) {
                            expFuncTableCube[r] = Math.exp(Math.cbrt(r));
                        }
                    }
                }
                if (!usePrecomputedTable) {
                    expFuncTable = null;
                    expFuncTableCube = null;
                }
                
                const pixelRadius = parseFloat(document.getElementById('planetRadius').value) || 40;
                const masses = [];
                const colors = [];
                const savedSettings = settingsManager.load();
                for (let i = 1; i <= 9; i++) {
                    const m = parseFloat(document.getElementById(`mass${i}`).value);
                    const c = savedSettings.planetColors[i - 1] || document.getElementById(`color${i}`).value;
                    masses.push(m);
                    colors.push(c);
                    if (i <= planetCount) {
                        if (m < 1000 || m > 100000) {
                            document.getElementById('error').textContent = 'Planet mass must be between 1000 and 100000';
                            return;
                        }
                    }
                }
                const planetMassMultiplier = parseFloat(document.getElementById('planetMassMultiplier').value) || 1.0;
                const adjustedMasses = masses.map(m => m * planetMassMultiplier);
                this.planets = [];
                this.frameCount = 0;
                this.settings = {
                    gravityFunctionType,
                    usePrecomputedTable,
                    gravityConstant: parseFloat(document.getElementById('gravityConstant').value),
                    planetCount,
                    boundaryType: document.getElementById('boundaryType').value,
                    collisionType: document.getElementById('collisionType').value,
                    centralMass: parseFloat(document.getElementById('centralMass').value),
                    planetRadius: pixelRadius,
                    maxGravitationalForce: parseFloat(document.getElementById('maxGravitationalForce').value),
                    startMode,
                    planetMasses: adjustedMasses,
                    planetColors: colors,
                    maxPlanetSpeed: parseFloat(document.getElementById('maxPlanetSpeed').value) || 700
                };
                
                if (startMode === 2) {
                    this.generateRandomPositions();
                } else if (startMode === 3 || startMode === 4) {
                    this.showScreen('');
                    this.generateManualPositions();
                }
            }
            
            startInactivityTimer() {
                if (this.inactivityTimer) clearTimeout(this.inactivityTimer);
                this.inactivityTimer = setTimeout(() => {
                    if (this.isRunning) {
                        this.isRunning = false;
                        console.log('Simulation automatically stopped due to inactivity. Returning to main menu.');
                        this.returnToSetup();
                    }
                }, INACTIVITY_TIMEOUT_SECONDS * 1000);
            }
            
            gameLoop(currentTime = 0) {
                if (!this.isRunning || this.isPaused) {
                    if (this.isPaused) {
                        requestAnimationFrame(this.boundGameLoop);
                    }
                    return;
                }
                const deltaTime = (currentTime - this.lastTime) / 1000;
                this.lastTime = currentTime;
                if (deltaTime <= 0 || isNaN(deltaTime) || deltaTime > 1) {
                    console.warn('Invalid deltaTime:', deltaTime);
                    requestAnimationFrame(this.boundGameLoop);
                    return;
                }
                this.checkSpeedLimits();
                let steps = this.physicsStepsPerFrame;
                if (this.isVeryComplexSituation()) steps *= 8;
                else if (this.isComplexSituation()) steps *= 4;
                else if (this.isModerateSituation()) steps *= 2;
                const subDeltaTime = deltaTime / steps;
                for (let i = 0; i < steps; i++) {
                    this.update(subDeltaTime);
                }
                this.render();
                this.frameCount++;
                requestAnimationFrame(this.boundGameLoop);
            }
            
            isVeryComplexSituation() { return this.checkProximity(VERY_COMPLEX_PROXIMITY_FACTOR); }
            isComplexSituation() { return this.checkProximity(PROXIMITY_FACTOR_COMPLEXITY); }
            isModerateSituation() { return this.checkProximity(PROXIMITY_FACTOR_COMPLEXITY_MODERATE); }
            
            checkProximity(factor) {
                for (let i = 0; i < this.planets.length; i++) {
                    for (let j = i + 1; j < this.planets.length; j++) {
                        const p1 = this.planets[i], p2 = this.planets[j];
                        const dx = toroidalDelta(p2.x, p1.x, GravityGame.worldWidth);
                        const dy = toroidalDelta(p2.y, p1.y, GravityGame.worldHeight);
                        const d = Math.sqrt(dx*dx + dy*dy);
                        if (d < (p1.radius + p2.radius) * factor) return true;
                    }
                }
                return false;
            }
            
            checkSpeedLimits() {
                const maxSpeed = this.settings.maxPlanetSpeed || 700;
                const halfW = GravityGame.worldWidth / 2;
                const halfH = GravityGame.worldHeight / 2;
                for (let planet of this.planets) {
                    const speed = planet.getSpeed();
                    if (isNaN(speed) || speed > maxSpeed) {
                        let nearestCenterX = planet.x;
                        let nearestCenterY = planet.y;
                        if (parseInt(this.settings.boundaryType) === 1) {
                            nearestCenterX = toroidalDelta(0, planet.x, GravityGame.worldWidth);
                            nearestCenterY = toroidalDelta(0, planet.y, GravityGame.worldHeight);
                        }
                        const distanceFromCenter = Math.hypot(nearestCenterX, nearestCenterY);
                        const safeRadius = Math.max(halfW, halfH) * 0.5;
                        if (distanceFromCenter > safeRadius) {
                            const newPos = this.findFurthestPointInWorld();
                            planet.x = newPos.x;
                            planet.y = newPos.y;
                            planet.vx = 0;
                            planet.vy = 0;
                        }
                    }
                }
            }
            
            returnToSetup() {
                this.isRunning = false;
                this.isPaused = false;
                
                if (this.touchControlState) {
                    this.stopTouchControl();
                }
                
                if (this.manualModeData) {
                    if (this.manualModeData.mode === 'coords') {
                        this.hideCoordinateInputUI();
                    } else {
                        this.hideManualModeUI();
                    }
                    this.manualModeData.isActive = false;
                    this.manualModeData = null;
                    this.manualArrows = [];
                }
                
                if (this.inactivityTimer) {
                    clearTimeout(this.inactivityTimer);
                    this.inactivityTimer = null;
                }
                
                this.lastCanvasClickTime = 0;
                this.planets = [];
                this.ctx.fillStyle = '#000000';
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
                this.showScreen('setupScreen');
            }
            
            findFurthestPointInWorld() {
                let bestX = 0, bestY = 0, maxMinDist = 0;
                for (let i = 0; i < MAX_ATTEMPTS_FIND_POINT; i++) {
                    const x = (Math.random() - 0.5) * GravityGame.worldWidth;
                    const y = (Math.random() - 0.5) * GravityGame.worldHeight;
                    if (Math.abs(x) > GravityGame.worldWidth / 2 - PLACEMENT_MARGIN) continue;
                    if (Math.abs(y) > GravityGame.worldHeight / 2 - PLACEMENT_MARGIN) continue;
                    let minDist = Infinity;
                    for (const p of this.planets) {
                        const dx = toroidalDelta(x, p.x, GravityGame.worldWidth);
                        const dy = toroidalDelta(y, p.y, GravityGame.worldHeight);
                        const d = Math.hypot(dx, dy);
                        if (d < minDist) minDist = d;
                    }
                    if (minDist > maxMinDist) {
                        maxMinDist = minDist;
                        bestX = x;
                        bestY = y;
                    }
                }
                return { x: bestX, y: bestY };
            }
            
            update(deltaTime) {
                this.handlePlanetCollisions();
                this.applyGravity(deltaTime);
                this.handleBoundaries();
                const boundaryType = parseInt(this.settings.boundaryType);
                if (boundaryType === 1) {
                    for (let p of this.planets) {
                        p.x = normalizeCoordinate(p.x, GravityGame.worldWidth);
                        p.y = normalizeCoordinate(p.y, GravityGame.worldHeight);
                    }
                }
            }
            
            evaluateDistance(distance, type) {
                const funcType = parseInt(type);
                
                if (funcType === 1) {
                    if (this.settings.usePrecomputedTable && expFuncTable !== null && Math.round(distance) < expFuncTable.length) {
                        return expFuncTable[Math.round(distance)];
                    }
                    return Math.exp(0.25 * Math.sqrt(distance));
                }
                
                if (funcType === 5) {
                    if (this.settings.usePrecomputedTable && expFuncTableCube !== null && Math.round(distance) < expFuncTableCube.length) {
                        return expFuncTableCube[Math.round(distance)];
                    }
                    return Math.exp(Math.cbrt(distance));
                }
                
                switch (funcType) {
                    case 2: return distance * distance;
                    case 3: return distance;
                    case 4: return Math.pow(distance, 1.5);
                    default: console.warn(`Unknown function type: ${funcType}, using quadratic (r¬≤) as fallback`);
                        return distance * distance;
                }
            }
            
            calculateForcesBetweenPlanets(p1, p2, G, funcType, maxGravitationalForce, boundaryType) {
                let dx, dy;
                if (boundaryType === 1) {
                    dx = toroidalDelta(p2.x, p1.x, GravityGame.worldWidth);
                    dy = toroidalDelta(p2.y, p1.y, GravityGame.worldHeight);
                } else {
                    dx = p2.x - p1.x;
                    dy = p2.y - p1.y;
                }
                const rawDx = dx, rawDy = dy;
                let distance = Math.sqrt(rawDx * rawDx + rawDy * rawDy);
                if (distance < p1.radius + p2.radius) distance = p1.radius + p2.radius;
                distance = Math.max(distance, 1);
                
                const rawDistanceFunc = this.evaluateDistance(distance, funcType);
                const rawForce = G * p1.mass * p2.mass / rawDistanceFunc;
                const force = Math.min(rawForce, maxGravitationalForce);
                if (distance > 0 && p1.mass > 0 && p2.mass > 0) {
                    const nx = rawDx / distance;
                    const ny = rawDy / distance;
                    p1.ax += force * nx / p1.mass;
                    p1.ay += force * ny / p1.mass;
                    p2.ax -= force * nx / p2.mass;
                    p2.ay -= force * ny / p2.mass;
                }
            }
            
            calculateForcesWithCentralMass(planet, G, funcType, maxGravitationalForce, centralMass, boundaryType) {
                let dx, dy;
                if (boundaryType === 1) {
                    dx = toroidalDelta(0, planet.x, GravityGame.worldWidth);
                    dy = toroidalDelta(0, planet.y, GravityGame.worldHeight);
                } else {
                    dx = 0 - planet.x;
                    dy = 0 - planet.y;
                }
                let distance = Math.sqrt(dx*dx + dy*dy);
                distance = Math.max(distance, 1);
                
                const rawDistanceFunc = this.evaluateDistance(distance, funcType);
                const rawForce = G * planet.mass * centralMass / rawDistanceFunc;
                const force = Math.min(rawForce, maxGravitationalForce);
                if (distance > 0 && planet.mass > 0) {
                    const nx = dx / distance;
                    const ny = dy / distance;
                    planet.ax += force * nx / planet.mass;
                    planet.ay += force * ny / planet.mass;
                }
            }
            
            calculateAndApplyForces(deltaTime) {
                const G = this.settings.gravityConstant;
                const funcType = parseInt(this.settings.gravityFunctionType);
                const boundaryType = parseInt(this.settings.boundaryType);
                const maxGravitationalForce = this.settings.maxGravitationalForce;
                const centralMass = this.settings.centralMass || 0;
                
                for (let p of this.planets) {
                    p.axPrev = p.ax;
                    p.ayPrev = p.ay;
                    p.ax = 0;
                    p.ay = 0;
                }
                
                for (let i = 0; i < this.planets.length; i++) {
                    for (let j = i + 1; j < this.planets.length; j++) {
                        this.calculateForcesBetweenPlanets(this.planets[i], this.planets[j], G, funcType, maxGravitationalForce, boundaryType);
                    }
                }
                
                if (centralMass > 0) {
                    for (let p of this.planets) {
                        this.calculateForcesWithCentralMass(p, G, funcType, maxGravitationalForce, centralMass, boundaryType);
                    }
                }
                
                for (let p of this.planets) {
                    if (p.mass > 0) {
                        p.x += p.vx * deltaTime + 0.5 * p.ax * deltaTime * deltaTime;
                        p.y += p.vy * deltaTime + 0.5 * p.ay * deltaTime * deltaTime;
                        p.vx += 0.5 * (p.axPrev + p.ax) * deltaTime;
                        p.vy += 0.5 * (p.ayPrev + p.ay) * deltaTime;
                    }
                }
            }
            
            applyGravity(deltaTime) {
                this.calculateAndApplyForces(deltaTime);
            }
            
            handleElasticCollisions() {
                const boundaryType = parseInt(this.settings.boundaryType);
                for (let i = 0; i < this.planets.length; i++) {
                    for (let j = i + 1; j < this.planets.length; j++) {
                        const p1 = this.planets[i], p2 = this.planets[j];
                        let dx, dy;
                        if (boundaryType === 1) {
                            dx = toroidalDelta(p2.x, p1.x, GravityGame.worldWidth);
                            dy = toroidalDelta(p2.y, p1.y, GravityGame.worldHeight);
                        } else {
                            dx = p2.x - p1.x;
                            dy = p2.y - p1.y;
                        }
                        let distance = Math.sqrt(dx*dx + dy*dy);
                        const minDistance = p1.radius + p2.radius;
                        if (distance < minDistance && distance > 0) {
                            const nx = dx / distance, ny = dy / distance;
                            const overlap = minDistance - distance;
                            const totalMass = p1.mass + p2.mass;
                            p1.x -= nx * overlap * (p2.mass / totalMass);
                            p1.y -= ny * overlap * (p2.mass / totalMass);
                            p2.x += nx * overlap * (p1.mass / totalMass);
                            p2.y += ny * overlap * (p1.mass / totalMass);
                            const dvx = p2.vx - p1.vx, dvy = p2.vy - p1.vy;
                            const dot = dvx * nx + dvy * ny;
                            if (dot < 0) {
                                let restitution = 1.0;
                                const impulse = -(1 + restitution) * dot / (1/p1.mass + 1/p2.mass);
                                p1.vx -= impulse * nx / p1.mass;
                                p1.vy -= impulse * ny / p1.mass;
                                p2.vx += impulse * nx / p2.mass;
                                p2.vy += impulse * ny / p2.mass;
                            }
                        }
                    }
                }
            }
            
            handleCenterCollisions() {
                const boundaryType = parseInt(this.settings.boundaryType);
                for (let i = 0; i < this.planets.length; i++) {
                    for (let j = i + 1; j < this.planets.length; j++) {
                        const p1 = this.planets[i], p2 = this.planets[j];
                        let dx, dy;
                        if (boundaryType === 1) {
                            dx = toroidalDelta(p2.x, p1.x, GravityGame.worldWidth);
                            dy = toroidalDelta(p2.y, p1.y, GravityGame.worldHeight);
                        } else {
                            dx = p2.x - p1.x;
                            dy = p2.y - p1.y;
                        }
                        const distance = Math.sqrt(dx*dx + dy*dy);
                        if (distance < MIN_COLLISION_DISTANCE) {
                            const newPos1 = this.findFurthestPointInWorld();
                            const newPos2 = this.findFurthestPointInWorld();
                            p1.x = newPos1.x;
                            p1.y = newPos1.y;
                            p1.vx = 0;
                            p1.vy = 0;
                            p2.x = newPos2.x;
                            p2.y = newPos2.y;
                            p2.vx = 0;
                            p2.vy = 0;
                            break;
                        }
                    }
                }
            }
            
            handleNoCollisions() {
                // Do nothing
            }
            
            handlePlanetCollisions() {
                const collisionType = parseInt(this.settings.collisionType);
                if (collisionType === 1) {
                    this.handleElasticCollisions();
                } else if (collisionType === 2) {
                    this.handleCenterCollisions();
                } else if (collisionType === 3) {
                    this.handleNoCollisions();
                }
            }
            
            handleBounce() {
                const halfW = GravityGame.worldWidth / 2;
                const halfH = GravityGame.worldHeight / 2;
                for (let i = this.planets.length - 1; i >= 0; i--) {
                    const p = this.planets[i];
                    if (p.x < -halfW + p.radius) { p.x = -halfW + p.radius; p.vx = Math.abs(p.vx); }
                    if (p.x > halfW - p.radius) { p.x = halfW - p.radius; p.vx = -Math.abs(p.vx); }
                    if (p.y < -halfH + p.radius) { p.y = -halfH + p.radius; p.vy = Math.abs(p.vy); }
                    if (p.y > halfH - p.radius) { p.y = halfH - p.radius; p.vy = -Math.abs(p.vy); }
                }
            }
            
            handleCircleBoundary() {
                const worldDiagonalHalf = Math.sqrt((GravityGame.worldWidth/2)**2 + (GravityGame.worldHeight/2)**2);
                for (let i = this.planets.length - 1; i >= 0; i--) {
                    const p = this.planets[i];
                    if (Math.sqrt(p.x*p.x + p.y*p.y) > worldDiagonalHalf) {
                        const newPos = this.findFurthestPointInWorld();
                        p.x = newPos.x;
                        p.y = newPos.y;
                        p.vx = 0;
                        p.vy = 0;
                    }
                }
            }
            
            handleBoundaries() {
                const boundaryType = parseInt(this.settings.boundaryType);
                if (boundaryType === 2) {
                    this.handleBounce();
                } else if (boundaryType === 4) {
                    this.handleCircleBoundary();
                }
            }
            
            render() {
                this.ctx.fillStyle = 'rgb(0, 0, 0)';
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
                if (this.manualModeData?.isActive && this.manualModeData.mode === 'drag') {
                    const center = this.worldToScreen(0, 0);
                    this.ctx.fillStyle = 'white';
                    this.ctx.beginPath();
                    const scaleX = this.canvas.width / GravityGame.worldWidth;
                    const dotRadius = Math.max(5, 10 * scaleX);
                    this.ctx.arc(center.x, center.y, dotRadius, 0, Math.PI * 2);
                    this.ctx.fill();
                }
                const scaleX = this.canvas.width / GravityGame.worldWidth;
                const scaleY = this.canvas.height / GravityGame.worldHeight;
                const boundaryType = parseInt(this.settings.boundaryType);
                for (let p of this.planets) {
                    if (boundaryType === 1) {
                        const offsets = [
                            [0,0],
                            [-GravityGame.worldWidth,0],[GravityGame.worldWidth,0],
                            [0,-GravityGame.worldHeight],[0,GravityGame.worldHeight],
                            [-GravityGame.worldWidth,-GravityGame.worldHeight],
                            [-GravityGame.worldWidth,GravityGame.worldHeight],
                            [GravityGame.worldWidth,-GravityGame.worldHeight],
                            [GravityGame.worldWidth,GravityGame.worldHeight]
                        ];
                        for (const [dx, dy] of offsets) {
                            const worldX = p.x + dx;
                            const worldY = p.y + dy;
                            const screen = this.worldToScreen(worldX, worldY);
                            if (screen.x + p.radius * scaleX >= 0 && screen.x - p.radius * scaleX <= this.canvas.width &&
                                screen.y + p.radius * scaleY >= 0 && screen.y - p.radius * scaleY <= this.canvas.height) {
                                p.draw(this.ctx, scaleX, scaleY, dx, dy);
                            }
                        }
                    } else {
                        p.draw(this.ctx, scaleX, scaleY);
                    }
                }
                if (this.manualModeData?.isActive) {
                    this.manualArrows.forEach(vec => {
                        this.drawVector(vec.start, vec.end, vec.color);
                    });
                }
            }
        }
        
        const game = new GravityGame();
        
        document.getElementById('startButton').addEventListener('click', function() {
            settingsManager.save(settingsManager.getCurrentUISettings());
            
            const gravityFunctionType = document.getElementById('gravityFunctionType').value;
            const usePrecomputedTable = document.getElementById('usePrecomputedTable').checked;
            const gravityConstant = parseFloat(document.getElementById('gravityConstant').value);
            const planetCount = document.getElementById('planetCount').value;
            const boundaryType = document.getElementById('boundaryType').value;
            const collisionType = document.getElementById('collisionType').value;
            const centralMass = parseFloat(document.getElementById('centralMass').value);
            const planetRadius = parseFloat(document.getElementById('planetRadius').value);
            const maxGravitationalForce = parseFloat(document.getElementById('maxGravitationalForce').value);
            const startMode = document.getElementById('startMode').value;
            const planetMassMultiplier = parseFloat(document.getElementById('planetMassMultiplier').value);
            const maxPlanetSpeed = parseFloat(document.getElementById('maxPlanetSpeed').value);
            const errorDiv = document.getElementById('error');
            errorDiv.textContent = '';
            const gravityInput = document.getElementById('gravityConstant');
            const minG = parseFloat(gravityInput.min);
            const maxG = parseFloat(gravityInput.max);
            if (gravityConstant < minG || gravityConstant > maxG) {
                errorDiv.textContent = `Gravity constant must be from ${minG} to ${maxG} for the selected function.`;
                return;
            }
            if (planetRadius < 5 || planetRadius > 65) {
                errorDiv.textContent = 'Planet radius must be between 5 and 65';
                return;
            }
            if (maxGravitationalForce < 1000000 || maxGravitationalForce > 100000000) {
                errorDiv.textContent = 'Max force must be between one million and one hundred million';
                return;
            }
            if (planetMassMultiplier < 0.1 || planetMassMultiplier > 10) {
                errorDiv.textContent = 'Planet mass multiplier must be between 0.1 and 10';
                return;
            }
            if (maxPlanetSpeed < 400 || maxPlanetSpeed > 3000) {
                errorDiv.textContent = 'Maximum speed must be –º–µ–∂–¥—É 400 –∏ 3000';
                return;
            }
            const masses = [], colors = [];
            for (let i = 1; i <= 9; i++) {
                const m = parseFloat(document.getElementById(`mass${i}`).value);
                const c = document.getElementById(`color${i}`).value;
                if (!/^#([A-Fa-f0-9]{6}|[A-Fa-f0-9]{3})$/.test(c)) {
                    errorDiv.textContent = `Invalid color format for planet ${i}: ${c}`;
                    return;
                }
                if (m <= 0) {
                    errorDiv.textContent = `Planet mass ${i} must be greater than 0`;
                    return;
                }
                masses.push(m);
                colors.push(c);
                if (i <= parseInt(planetCount)) {
                    if (m < 1000 || m > 100000) {
                        errorDiv.textContent = 'Planet mass must be between 1000 and 100000';
                        return;
                    }
                }
            }
            if (centralMass < 0 || centralMass > 10000000) {
                errorDiv.textContent = 'Central mass must be between zero and ten million';
                return;
            }
            game.settings = {
                gravityFunctionType, usePrecomputedTable, gravityConstant, planetCount, boundaryType, collisionType,
                centralMass, planetRadius, maxGravitationalForce, startMode,
                planetMasses: masses,
                planetColors: colors,
                maxPlanetSpeed
            };
            game.showScreen('');
            game.startGame();
        });
        
        function enterFullscreen() {
            const elem = document.documentElement;
            if (elem.requestFullscreen) elem.requestFullscreen().catch(() => {});
            else if (elem.webkitRequestFullscreen) elem.webkitRequestFullscreen();
            else if (elem.msRequestFullscreen) elem.msRequestFullscreen();
        }
        
        window.addEventListener('load', () => setTimeout(enterFullscreen, 1000));
        ['touchstart', 'click'].forEach(e => document.addEventListener(e, enterFullscreen, {once: true}));
        
        document.addEventListener('DOMContentLoaded', () => {
            localization.initMenuUI();
        });
        
        document.addEventListener('keydown', (event) => {
            if (event.key !== 'Escape') return;
            
            const activeModals = ['licenseOverlay', 'offlineOverlay', 'aboutOverlay'].filter(id => 
                document.getElementById(id).style.display === 'flex'
            );
            
            if (activeModals.length > 0) {
                const topModal = activeModals[activeModals.length - 1];
                document.getElementById(topModal).style.display = 'none';
                if (topModal === 'licenseOverlay' || topModal === 'offlineOverlay') {
                    document.getElementById('aboutOverlay').style.display = 'flex';
                } else if (topModal === 'aboutOverlay') {
                    document.getElementById('setupScreen').style.display = 'flex';
                }
            } 
            else if (game && (game.isRunning || game.manualModeData?.isActive)) {
                game.returnToSetup();
            } 
            else {
                game.showScreen('setupScreen');
            }
        });
    </script>
</body>
</html>